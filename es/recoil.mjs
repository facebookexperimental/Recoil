import react,{useRef as useRef$2}from"react";import reactDom from"react-dom";function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}class AbstractRecoilValue{constructor(newKey){_defineProperty(this,"key",void 0),this.key=newKey}}class RecoilState extends AbstractRecoilValue{}class RecoilValueReadOnly extends AbstractRecoilValue{}var Recoil_RecoilValue={AbstractRecoilValue:AbstractRecoilValue,RecoilState:RecoilState,RecoilValueReadOnly:RecoilValueReadOnly,isRecoilValue:function(x){return x instanceof RecoilState||x instanceof RecoilValueReadOnly}},Recoil_RecoilValue_1=Recoil_RecoilValue.AbstractRecoilValue,Recoil_RecoilValue_2=Recoil_RecoilValue.RecoilState,Recoil_RecoilValue_3=Recoil_RecoilValue.RecoilValueReadOnly,Recoil_RecoilValue_4=Recoil_RecoilValue.isRecoilValue,Recoil_RecoilValue$1=Object.freeze({__proto__:null,AbstractRecoilValue:Recoil_RecoilValue_1,RecoilState:Recoil_RecoilValue_2,RecoilValueReadOnly:Recoil_RecoilValue_3,isRecoilValue:Recoil_RecoilValue_4});class DefaultValue{}const DEFAULT_VALUE=new DefaultValue;class RecoilValueNotReady extends Error{constructor(key){super(`Tried to set the value of Recoil selector ${key} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const nodes=new Map,recoilValues=new Map;class NodeMissingError extends Error{}var Recoil_Node={nodes:nodes,recoilValues:recoilValues,registerNode:function(node){if(nodes.has(node.key)){const message=`Duplicate atom key "${node.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(message)}nodes.set(node.key,node);const recoilValue=null==node.set?new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key):new Recoil_RecoilValue$1.RecoilState(node.key);return recoilValues.set(node.key,recoilValue),recoilValue},getNode:function(key){const node=nodes.get(key);if(null==node)throw new NodeMissingError(`Missing definition for RecoilValue: "${key}""`);return node},getNodeMaybe:function(key){return nodes.get(key)},NodeMissingError:NodeMissingError,DefaultValue:DefaultValue,DEFAULT_VALUE:DEFAULT_VALUE,RecoilValueNotReady:RecoilValueNotReady};var Recoil_Queue={enqueueExecution:function(s,f){f()}};var Recoil_CopyOnWrite={setByAddingToSet:function(set,v){const next=new Set(set);return next.add(v),next},setByDeletingFromSet:function(set,v){const next=new Set(set);return next.delete(v),next},mapBySettingInMap:function(map,k,v){const next=new Map(map);return next.set(k,v),next},mapByUpdatingInMap:function(map,k,updater){const next=new Map(map);return next.set(k,updater(next.get(k))),next},mapByDeletingFromMap:function(map,k){const next=new Map(map);return next.delete(k),next},mapByDeletingMultipleFromMap:function(map,ks){const next=new Map(map);return ks.forEach(k=>next.delete(k)),next}};const{mapByDeletingFromMap:mapByDeletingFromMap$1,mapBySettingInMap:mapBySettingInMap$1,setByAddingToSet:setByAddingToSet$1}=Recoil_CopyOnWrite,{getNode:getNode$1,getNodeMaybe:getNodeMaybe$1}=Recoil_Node,emptySet=Object.freeze(new Set);class ReadOnlyRecoilValueError extends Error{}var Recoil_FunctionalCore={getNodeLoadable:function(store,state,key){return getNode$1(key).get(store,state)},peekNodeLoadable:function(store,state,key){return getNode$1(key).peek(store,state)},setNodeValue:function(store,state,key,newValue){const node=getNode$1(key);if(null==node.set)throw new ReadOnlyRecoilValueError("Attempt to set read-only RecoilValue: "+key);return node.set(store,state,newValue)},setUnvalidatedAtomValue:function(state,key,newValue){var _node$invalidate;const node=getNodeMaybe$1(key);return null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node),{...state,atomValues:mapByDeletingFromMap$1(state.atomValues,key),nonvalidatedAtoms:mapBySettingInMap$1(state.nonvalidatedAtoms,key,newValue),dirtyAtoms:setByAddingToSet$1(state.dirtyAtoms,key)}},cleanUpNode:function(store,key){getNode$1(key).cleanUp(store)},getDownstreamNodes:function(store,state,keys){const visitedNodes=new Set,visitingNodes=Array.from(keys),graph=store.getGraph(state.version);for(let key=visitingNodes.pop();key;key=visitingNodes.pop()){var _graph$nodeToNodeSubs;visitedNodes.add(key);const subscribedNodes=null!==(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(key))&&void 0!==_graph$nodeToNodeSubs?_graph$nodeToNodeSubs:emptySet;for(const downstreamNode of subscribedNodes)visitedNodes.has(downstreamNode)||visitingNodes.push(downstreamNode)}return visitedNodes}};var Recoil_differenceSets=function(set,...setsWithValuesToRemove){const ret=new Set;FIRST:for(const value of set){for(const otherSet of setsWithValuesToRemove)if(otherSet.has(value))continue FIRST;ret.add(value)}return ret};var Recoil_mapMap=function(map,callback){const result=new Map;return map.forEach((value,key)=>{result.set(key,callback(value,key))}),result};var Recoil_nullthrows=function(x,message){if(null!=x)return x;throw new Error(null!=message?message:"Got unexpected null or undefined")};function mergeDependencyMapIntoGraph(deps,graph,olderGraph){const{nodeDeps:nodeDeps,nodeToNodeSubscriptions:nodeToNodeSubscriptions}=graph;deps.forEach((upstreams,downstream)=>{const existingUpstreams=nodeDeps.get(downstream);if(existingUpstreams&&olderGraph&&existingUpstreams!==olderGraph.nodeDeps.get(downstream))return;nodeDeps.set(downstream,new Set(upstreams));if((null==existingUpstreams?upstreams:Recoil_differenceSets(upstreams,existingUpstreams)).forEach(upstream=>{nodeToNodeSubscriptions.has(upstream)||nodeToNodeSubscriptions.set(upstream,new Set);Recoil_nullthrows(nodeToNodeSubscriptions.get(upstream)).add(downstream)}),existingUpstreams){Recoil_differenceSets(existingUpstreams,upstreams).forEach(upstream=>{if(!nodeToNodeSubscriptions.has(upstream))return;const existing=Recoil_nullthrows(nodeToNodeSubscriptions.get(upstream));existing.delete(downstream),0===existing.size&&nodeToNodeSubscriptions.delete(upstream)})}})}var Recoil_Graph={addToDependencyMap:function(downstream,upstream,dependencyMap){dependencyMap.has(downstream)||dependencyMap.set(downstream,new Set),Recoil_nullthrows(dependencyMap.get(downstream)).add(upstream)},cloneGraph:function(graph){return{nodeDeps:Recoil_mapMap(graph.nodeDeps,s=>new Set(s)),nodeToNodeSubscriptions:Recoil_mapMap(graph.nodeToNodeSubscriptions,s=>new Set(s))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(from,into){from.forEach((upstreamDeps,downstreamNode)=>{into.has(downstreamNode)||into.set(downstreamNode,new Set);const deps=Recoil_nullthrows(into.get(downstreamNode));upstreamDeps.forEach(dep=>deps.add(dep))})},saveDependencyMapToStore:function(dependencyMap,store,version){var _storeState$nextTree,_storeState$previousT,_storeState$previousT2,_storeState$previousT3;const storeState=store.getState();version!==storeState.currentTree.version&&version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&(null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT||_storeState$previousT.version);const graph=store.getGraph(version);if(mergeDependencyMapIntoGraph(dependencyMap,graph),version===(null===(_storeState$previousT2=storeState.previousTree)||void 0===_storeState$previousT2?void 0:_storeState$previousT2.version)){mergeDependencyMapIntoGraph(dependencyMap,store.getGraph(storeState.currentTree.version),graph)}if(version===(null===(_storeState$previousT3=storeState.previousTree)||void 0===_storeState$previousT3?void 0:_storeState$previousT3.version)||version===storeState.currentTree.version){var _storeState$nextTree2;const nextVersion=null===(_storeState$nextTree2=storeState.nextTree)||void 0===_storeState$nextTree2?void 0:_storeState$nextTree2.version;if(void 0!==nextVersion){mergeDependencyMapIntoGraph(dependencyMap,store.getGraph(nextVersion),graph)}}}};var Recoil_Tracing={trace:function(message,node,fn){return fn()},wrap:function(fn){return fn}};var Recoil_unionSets=function(...sets){const result=new Set;for(const set of sets)for(const value of set)result.add(value);return result};const{mapByDeletingFromMap:mapByDeletingFromMap$2,mapByDeletingMultipleFromMap:mapByDeletingMultipleFromMap$1}=Recoil_CopyOnWrite,{getNodeLoadable:getNodeLoadable$1,setNodeValue:setNodeValue$1,setUnvalidatedAtomValue:setUnvalidatedAtomValue$1}=Recoil_FunctionalCore,{saveDependencyMapToStore:saveDependencyMapToStore$1}=Recoil_Graph,{DefaultValue:DefaultValue$1,RecoilValueNotReady:RecoilValueNotReady$1}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,RecoilValueReadOnly:RecoilValueReadOnly$1,isRecoilValue:isRecoilValue$1}=Recoil_RecoilValue$1;function applyAtomValueWrites(atomValues,writes){const result=Recoil_mapMap(atomValues,v=>v);return writes.forEach((v,k)=>{"hasValue"===v.state&&v.contents instanceof DefaultValue$1?result.delete(k):result.set(k,v)}),result}function setRecoilValue(store,recoilValue,valueOrUpdater){const{key:key}=recoilValue;Recoil_Tracing.trace("set RecoilValue",key,()=>store.replaceState(Recoil_Tracing.wrap(state=>{const newValue=function(store,{key:key},valueOrUpdater){if("function"==typeof valueOrUpdater){var _storeState$nextTree2;const storeState=store.getState(),state=null!==(_storeState$nextTree2=storeState.nextTree)&&void 0!==_storeState$nextTree2?_storeState$nextTree2:storeState.currentTree,current=getNodeLoadable$1(store,state,key)[1];if("loading"===current.state)throw new RecoilValueNotReady$1(key);if("hasError"===current.state)throw current.contents;return valueOrUpdater(current.contents)}return valueOrUpdater}(store,recoilValue,valueOrUpdater),[depMap,writes]=setNodeValue$1(store,state,key,newValue),writtenNodes=new Set(writes.keys());return saveDependencyMapToStore$1(depMap,store,state.version),{...state,dirtyAtoms:Recoil_unionSets(state.dirtyAtoms,writtenNodes),atomValues:applyAtomValueWrites(state.atomValues,writes),nonvalidatedAtoms:mapByDeletingMultipleFromMap$1(state.nonvalidatedAtoms,writtenNodes)}})))}let subscriptionID=0;var Recoil_RecoilValueInterface={RecoilValueReadOnly:RecoilValueReadOnly$1,AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,getRecoilValueAsLoadable:function(store,{key:key},treeState=store.getState().currentTree){var _storeState$nextTree,_storeState$previousT;const storeState=store.getState();treeState.version!==storeState.currentTree.version&&treeState.version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&(treeState.version,null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT||_storeState$previousT.version);const[dependencyMap,loadable]=getNodeLoadable$1(store,treeState,key);return saveDependencyMapToStore$1(dependencyMap,store,treeState.version),loadable},setRecoilValue:setRecoilValue,setRecoilValueLoadable:function(store,recoilValue,loadable){if(loadable instanceof DefaultValue$1)return setRecoilValue(store,recoilValue,loadable);const{key:key}=recoilValue;Recoil_Tracing.trace("set RecoilValue",key,()=>store.replaceState(Recoil_Tracing.wrap(state=>{const writtenNode=new Set([key]);return{...state,dirtyAtoms:Recoil_unionSets(state.dirtyAtoms,writtenNode),atomValues:applyAtomValueWrites(state.atomValues,new Map([[key,loadable]])),nonvalidatedAtoms:mapByDeletingFromMap$2(state.nonvalidatedAtoms,key)}})))},markRecoilValueModified:function(store,{key:key}){Recoil_Tracing.trace("mark RecoilValue modified",key,()=>store.replaceState(Recoil_Tracing.wrap(state=>({...state,dirtyAtoms:Recoil_unionSets(state.dirtyAtoms,new Set([key]))}))))},setUnvalidatedRecoilValue:function(store,{key:key},newValue){Recoil_Tracing.trace("set unvalidated persisted atom",key,()=>store.replaceState(Recoil_Tracing.wrap(state=>setUnvalidatedAtomValue$1(state,key,newValue))))},subscribeToRecoilValue:function(store,{key:key},callback,componentDebugName=null){const subID=subscriptionID++,storeState=store.getState();return storeState.nodeToComponentSubscriptions.has(key)||storeState.nodeToComponentSubscriptions.set(key,new Map),Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID,[null!=componentDebugName?componentDebugName:"<not captured>",callback]),{release:()=>{const storeState=store.getState(),subs=storeState.nodeToComponentSubscriptions.get(key);void 0!==subs&&subs.has(subID)&&(subs.delete(subID),0===subs.size&&storeState.nodeToComponentSubscriptions.delete(key))}}},isRecoilValue:isRecoilValue$1,applyAtomValueWrites:applyAtomValueWrites};var Recoil_concatIterables=function*(iters){for(const iter of iters)for(const val of iter)yield val};var Recoil_filterIterable=function*(iterable,predicate){let index=0;for(const value of iterable)predicate(value,index++)&&(yield value)};const gks=new Map;function Recoil_gkx(gk){var _gks$get;return null!==(_gks$get=gks.get(gk))&&void 0!==_gks$get&&_gks$get}Recoil_gkx.setPass=gk=>{gks.set(gk,!0)},Recoil_gkx.setFail=gk=>{gks.set(gk,!1)};var Recoil_gkx_1=Recoil_gkx;var Recoil_mapIterable=function(iterable,callback){return function*(){let index=0;for(const value of iterable)yield callback(value,index++)}()};const{graph:graph$1}=Recoil_Graph;let nextTreeStateVersion=0;const getNextTreeStateVersion=()=>nextTreeStateVersion++;function makeEmptyTreeState(){const version=getNextTreeStateVersion();return{version:version,stateID:version,transactionMetadata:{},dirtyAtoms:new Set,atomValues:new Map,nonvalidatedAtoms:new Map}}var Recoil_State={makeEmptyTreeState:makeEmptyTreeState,makeEmptyStoreState:function(){const currentTree=makeEmptyTreeState();return{currentTree:currentTree,nextTree:null,previousTree:null,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(currentTree.version,graph$1()),versionsUsedByComponent:new Map}},getNextTreeStateVersion:getNextTreeStateVersion};const{getDownstreamNodes:getDownstreamNodes$1,peekNodeLoadable:peekNodeLoadable$1}=Recoil_FunctionalCore,{graph:graph$2}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$1,recoilValues:recoilValues$1}=Recoil_Node,{getRecoilValueAsLoadable:getRecoilValueAsLoadable$1,setRecoilValue:setRecoilValue$1}=Recoil_RecoilValueInterface,{getNextTreeStateVersion:getNextTreeStateVersion$1,makeEmptyStoreState:makeEmptyStoreState$1}=Recoil_State;function recoilValuesForKeys(keys){return Recoil_mapIterable(keys,key=>Recoil_nullthrows(recoilValues$1.get(key)))}class Snapshot{constructor(storeState){_defineProperty(this,"_store",void 0),_defineProperty(this,"getLoadable",recoilValue=>getRecoilValueAsLoadable$1(this._store,recoilValue)),_defineProperty(this,"getPromise",recoilValue=>Recoil_gkx_1("recoil_async_selector_refactor")?this.getLoadable(recoilValue).toPromise().then(({value:value})=>value):this.getLoadable(recoilValue).toPromise()),_defineProperty(this,"getNodes_UNSTABLE",opt=>{if(!0===(null==opt?void 0:opt.isModified)){if(!1===(null==opt?void 0:opt.isInitialized))return[];return recoilValuesForKeys(this._store.getState().currentTree.dirtyAtoms)}const knownAtoms=this._store.getState().knownAtoms,knownSelectors=this._store.getState().knownSelectors;return null==(null==opt?void 0:opt.isInitialized)?recoilValues$1.values():!0===opt.isInitialized?recoilValuesForKeys(Recoil_concatIterables([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):Recoil_filterIterable(recoilValues$1.values(),({key:key})=>!knownAtoms.has(key)&&!knownSelectors.has(key))}),_defineProperty(this,"getDeps_UNSTABLE",recoilValue=>{this.getLoadable(recoilValue);const deps=this._store.getGraph(this._store.getState().currentTree.version).nodeDeps.get(recoilValue.key);return recoilValuesForKeys(null!=deps?deps:[])}),_defineProperty(this,"getSubscribers_UNSTABLE",({key:key})=>{const state=this._store.getState().currentTree;return{nodes:recoilValuesForKeys(Recoil_filterIterable(getDownstreamNodes$1(this._store,state,new Set([key])),nodeKey=>nodeKey!==key))}}),_defineProperty(this,"getInfo_UNSTABLE",recoilValue=>{var _graph$nodeDeps$get;const{key:key}=recoilValue,state=this._store.getState().currentTree,graph=this._store.getGraph(state.version);return{loadable:peekNodeLoadable$1(this._store,state,key),isActive:this._store.getState().knownAtoms.has(key)||this._store.getState().knownSelectors.has(key),isSet:state.atomValues.has(key),isModified:state.dirtyAtoms.has(key),type:this._store.getState().knownAtoms.has(key)?"atom":this._store.getState().knownSelectors.has(key)?"selector":void 0,deps:recoilValuesForKeys(null!==(_graph$nodeDeps$get=graph.nodeDeps.get(key))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:[]),subscribers:this.getSubscribers_UNSTABLE(recoilValue)}}),_defineProperty(this,"map",mapper=>{const mutableSnapshot=new MutableSnapshot(this);return mapper(mutableSnapshot),cloneSnapshot(mutableSnapshot.getStore_INTERNAL())}),_defineProperty(this,"asyncMap",async mapper=>{const mutableSnapshot=new MutableSnapshot(this);return await mapper(mutableSnapshot),cloneSnapshot(mutableSnapshot.getStore_INTERNAL())}),this._store={getState:()=>storeState,replaceState:replacer=>{storeState.currentTree=replacer(storeState.currentTree)},getGraph:version=>{const graphs=storeState.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$2();return graphs.set(version,newGraph),newGraph},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}}}getStore_INTERNAL(){return this._store}getID(){return this.getID_INTERNAL()}getID_INTERNAL(){return this._store.getState().currentTree.stateID}}function cloneStoreState(store,treeState,bumpVersion=!1){const storeState=store.getState(),version=bumpVersion?getNextTreeStateVersion$1():treeState.version;return{currentTree:bumpVersion?{version:version,stateID:version,transactionMetadata:{...treeState.transactionMetadata},dirtyAtoms:new Set(treeState.dirtyAtoms),atomValues:new Map(treeState.atomValues),nonvalidatedAtoms:new Map(treeState.nonvalidatedAtoms)}:treeState,nextTree:null,previousTree:null,knownAtoms:new Set(storeState.knownAtoms),knownSelectors:new Set(storeState.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(version,store.getGraph(treeState.version)),versionsUsedByComponent:new Map}}function cloneSnapshot(store,version="current"){const storeState=store.getState(),treeState="current"===version?storeState.currentTree:Recoil_nullthrows(storeState.previousTree);return new Snapshot(cloneStoreState(store,treeState))}class MutableSnapshot extends Snapshot{constructor(snapshot){super(cloneStoreState(snapshot.getStore_INTERNAL(),snapshot.getStore_INTERNAL().getState().currentTree,!0)),_defineProperty(this,"set",(recoilState,newValueOrUpdater)=>{const store=this.getStore_INTERNAL();setRecoilValue$1(store,recoilState,newValueOrUpdater)}),_defineProperty(this,"reset",recoilState=>setRecoilValue$1(this.getStore_INTERNAL(),recoilState,DEFAULT_VALUE$1))}}var Recoil_Snapshot={Snapshot:Snapshot,MutableSnapshot:MutableSnapshot,freshSnapshot:function(){return new Snapshot(makeEmptyStoreState$1())},cloneSnapshot:cloneSnapshot},Recoil_Snapshot_1=Recoil_Snapshot.Snapshot,Recoil_Snapshot_2=Recoil_Snapshot.MutableSnapshot,Recoil_Snapshot_3=Recoil_Snapshot.freshSnapshot,Recoil_Snapshot_4=Recoil_Snapshot.cloneSnapshot,Recoil_Snapshot$1=Object.freeze({__proto__:null,Snapshot:Recoil_Snapshot_1,MutableSnapshot:Recoil_Snapshot_2,freshSnapshot:Recoil_Snapshot_3,cloneSnapshot:Recoil_Snapshot_4});const{useContext:useContext,useEffect:useEffect,useMemo:useMemo,useRef:useRef,useState:useState}=react,{cleanUpNode:cleanUpNode$1,getDownstreamNodes:getDownstreamNodes$2,setNodeValue:setNodeValue$2,setUnvalidatedAtomValue:setUnvalidatedAtomValue$2}=Recoil_FunctionalCore,{graph:graph$3,saveDependencyMapToStore:saveDependencyMapToStore$2}=Recoil_Graph,{cloneGraph:cloneGraph$1}=Recoil_Graph,{applyAtomValueWrites:applyAtomValueWrites$1}=Recoil_RecoilValueInterface,{freshSnapshot:freshSnapshot$1}=Recoil_Snapshot$1,{getNextTreeStateVersion:getNextTreeStateVersion$2,makeEmptyStoreState:makeEmptyStoreState$2}=Recoil_State,{mapByDeletingMultipleFromMap:mapByDeletingMultipleFromMap$2}=Recoil_CopyOnWrite;function notInAContext(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const defaultStore=Object.freeze({getState:notInAContext,replaceState:notInAContext,getGraph:notInAContext,subscribeToTransactions:notInAContext,addTransactionMetadata:notInAContext});let stateReplacerIsBeingExecuted=!1;function startNextTreeIfNeeded(storeState){if(stateReplacerIsBeingExecuted)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");if(null===storeState.nextTree){const version=storeState.currentTree.version,nextVersion=getNextTreeStateVersion$2();storeState.nextTree={...storeState.currentTree,version:nextVersion,stateID:nextVersion,dirtyAtoms:new Set,transactionMetadata:{}},storeState.graphsByVersion.set(nextVersion,cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))))}}const AppContext=react.createContext({current:defaultStore}),useStoreRef=()=>useContext(AppContext),MutableSourceContext=react.createContext(null);function sendEndOfBatchNotifications(store){const storeState=store.getState(),treeState=storeState.currentTree,dirtyAtoms=treeState.dirtyAtoms;if(dirtyAtoms.size){for(const[key,subscriptions]of storeState.nodeTransactionSubscriptions)if(dirtyAtoms.has(key))for(const[_,subscription]of subscriptions)subscription(store);for(const[_,subscription]of storeState.transactionSubscriptions)subscription(store);const dependentNodes=getDownstreamNodes$2(store,treeState,dirtyAtoms);for(const key of dependentNodes){const comps=storeState.nodeToComponentSubscriptions.get(key);if(comps)for(const[_subID,[_debugName,callback]]of comps)callback(treeState)}let nodeNames="[available in dev build]";storeState.suspendedComponentResolvers.forEach(cb=>Recoil_Tracing.trace("value became available, waking components",nodeNames,cb))}storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb=>cb(treeState)),storeState.queuedComponentCallbacks_DEPRECATED.splice(0,storeState.queuedComponentCallbacks_DEPRECATED.length)}function Batcher(props){const storeRef=useStoreRef(),[_,setState]=useState([]);return props.setNotifyBatcherOfChange(()=>setState({})),useEffect(()=>{Recoil_Queue.enqueueExecution("Batcher",()=>{const storeState=storeRef.current.getState(),{nextTree:nextTree}=storeState;if(null===nextTree)return;storeState.previousTree=storeState.currentTree,storeState.currentTree=nextTree,storeState.nextTree=null,sendEndOfBatchNotifications(storeRef.current);const discardedVersion=Recoil_nullthrows(storeState.previousTree).version;storeState.graphsByVersion.delete(discardedVersion),storeState.previousTree=null})}),null}let nextID=0;var Recoil_RecoilRoot_react={useStoreRef:useStoreRef,useRecoilMutableSource:()=>useContext(MutableSourceContext),RecoilRoot:function({initializeState_DEPRECATED:initializeState_DEPRECATED,initializeState:initializeState,store_INTERNAL:storeProp,children:children}){var _createMutableSource;let storeState;const notifyBatcherOfChange=useRef(null),createMutableSource=null!==(_createMutableSource=react.createMutableSource)&&void 0!==_createMutableSource?_createMutableSource:react.unstable_createMutableSource,store=null!=storeProp?storeProp:{getState:()=>storeState.current,replaceState:replacer=>{const storeState=storeRef.current.getState();startNextTreeIfNeeded(storeState);const nextTree=Recoil_nullthrows(storeState.nextTree);let replaced;try{stateReplacerIsBeingExecuted=!0,replaced=replacer(nextTree)}finally{stateReplacerIsBeingExecuted=!1}replaced!==nextTree&&(storeState.nextTree=replaced,Recoil_nullthrows(notifyBatcherOfChange.current)())},getGraph:version=>{const graphs=storeState.current.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$3();return graphs.set(version,newGraph),newGraph},subscribeToTransactions:(callback,key)=>{if(null==key){const{transactionSubscriptions:transactionSubscriptions}=storeRef.current.getState(),id=nextID++;return transactionSubscriptions.set(id,callback),{release:()=>{transactionSubscriptions.delete(id)}}}{const{nodeTransactionSubscriptions:nodeTransactionSubscriptions}=storeRef.current.getState();nodeTransactionSubscriptions.has(key)||nodeTransactionSubscriptions.set(key,new Map);const id=nextID++;return Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id,callback),{release:()=>{const subs=nodeTransactionSubscriptions.get(key);subs&&(subs.delete(id),0===subs.size&&nodeTransactionSubscriptions.delete(key))}}}},addTransactionMetadata:metadata=>{startNextTreeIfNeeded(storeRef.current.getState());for(const k of Object.keys(metadata))Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k]=metadata[k]}},storeRef=useRef(store);storeState=useRef(null!=initializeState_DEPRECATED?function(store,initializeState){const initial=makeEmptyStoreState$2();return initializeState({set:(atom,value)=>{const state=initial.currentTree,[depMap,writes]=setNodeValue$2(store,state,atom.key,value),writtenNodes=new Set(writes.keys());saveDependencyMapToStore$2(depMap,store,state.version);const nonvalidatedAtoms=mapByDeletingMultipleFromMap$2(state.nonvalidatedAtoms,writtenNodes);initial.currentTree={...state,dirtyAtoms:Recoil_unionSets(state.dirtyAtoms,writtenNodes),atomValues:applyAtomValueWrites$1(state.atomValues,writes),nonvalidatedAtoms:nonvalidatedAtoms}},setUnvalidatedAtomValues:atomValues=>{atomValues.forEach((v,k)=>{initial.currentTree=setUnvalidatedAtomValue$2(initial.currentTree,k,v)})}}),initial}(store,initializeState_DEPRECATED):null!=initializeState?function(initializeState){return freshSnapshot$1().map(initializeState).getStore_INTERNAL().getState()}(initializeState):makeEmptyStoreState$2());const mutableSource=useMemo(()=>createMutableSource?createMutableSource(storeState,()=>storeState.current.currentTree.version):null,[createMutableSource,storeState]);return useEffect(()=>()=>{for(const atomKey of storeRef.current.getState().knownAtoms)cleanUpNode$1(storeRef.current,atomKey)},[]),react.createElement(AppContext.Provider,{value:storeRef},react.createElement(MutableSourceContext.Provider,{value:mutableSource},react.createElement(Batcher,{setNotifyBatcherOfChange:function(x){notifyBatcherOfChange.current=x}}),children))},sendEndOfBatchNotifications_FOR_TESTING:sendEndOfBatchNotifications};const{unstable_batchedUpdates:unstable_batchedUpdates}=reactDom;var Recoil_ReactBatchedUpdates={unstable_batchedUpdates:unstable_batchedUpdates};const{unstable_batchedUpdates:unstable_batchedUpdates$1}=Recoil_ReactBatchedUpdates;let batcher=unstable_batchedUpdates$1;var Recoil_batcher={getBatcher:()=>batcher,setBatcher:newBatcher=>{batcher=newBatcher},batchUpdates:callback=>batcher(callback)};var Recoil_filterMap=function(map,callback){const result=new Map;for(const[key,value]of map)callback(value,key)&&result.set(key,value);return result};var Recoil_filterSet=function(set,callback){const result=new Set;for(const value of set)callback(value)&&result.add(value);return result};var Recoil_invariant=function(condition,message){if(!condition)throw new Error(message)};var _useMutableSource,Recoil_mergeMaps=function(...maps){const result=new Map;for(let i=0;i<maps.length;i++){const iterator=maps[i].keys();let nextKey;for(;!(nextKey=iterator.next()).done;)result.set(nextKey.value,maps[i].get(nextKey.value))}return result};const useMutableSource=null!==(_useMutableSource=react.useMutableSource)&&void 0!==_useMutableSource?_useMutableSource:react.unstable_useMutableSource;var Recoil_mutableSource={mutableSourceExists:function(){return useMutableSource&&!("undefined"!=typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:useMutableSource};function useComponentName(){useRef$2();return"<component name available only in dev mode>"}const{useCallback:useCallback,useEffect:useEffect$1,useMemo:useMemo$1,useRef:useRef$1,useState:useState$1}=react,{DEFAULT_VALUE:DEFAULT_VALUE$2,getNode:getNode$2,nodes:nodes$1}=Recoil_Node,{useRecoilMutableSource:useRecoilMutableSource$1,useStoreRef:useStoreRef$1}=Recoil_RecoilRoot_react,{AbstractRecoilValue:AbstractRecoilValue$2,getRecoilValueAsLoadable:getRecoilValueAsLoadable$2,setRecoilValue:setRecoilValue$2,setRecoilValueLoadable:setRecoilValueLoadable$1,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$1,subscribeToRecoilValue:subscribeToRecoilValue$1}=Recoil_RecoilValueInterface,{Snapshot:Snapshot$1,cloneSnapshot:cloneSnapshot$1}=Recoil_Snapshot$1,{batchUpdates:batchUpdates$1}=Recoil_batcher,{setByAddingToSet:setByAddingToSet$2}=Recoil_CopyOnWrite,{mutableSourceExists:mutableSourceExists$1,useMutableSource:useMutableSource$1}=Recoil_mutableSource;function handleLoadable(loadable,atom,storeRef){if("hasValue"===loadable.state)return loadable.contents;if("loading"===loadable.state){throw new Promise(resolve=>{storeRef.current.getState().suspendedComponentResolvers.add(resolve)})}throw"hasError"===loadable.state?loadable.contents:new Error(`Invalid value of loadable atom "${atom.key}"`)}function useRecoilValueLoadable(recoilValue){return mutableSourceExists$1()?function(recoilValue){const storeRef=useStoreRef$1(),getValue=useCallback(()=>getRecoilValueAsLoadable$2(storeRef.current,recoilValue,storeRef.current.getState().currentTree),[storeRef,recoilValue]),componentName=useComponentName(),subscribe=useCallback((_something,callback)=>{const store=storeRef.current,sub=subscribeToRecoilValue$1(store,recoilValue,()=>{Recoil_Tracing.trace("RecoilValue subscription fired",recoilValue.key,()=>{callback()})},componentName);return()=>sub.release(store)},[recoilValue,storeRef,componentName]);return useMutableSource$1(useRecoilMutableSource$1(),getValue,subscribe)}(recoilValue):function(recoilValue){const storeRef=useStoreRef$1(),[_,forceUpdate]=useState$1([]),componentName=useComponentName();return useEffect$1(()=>{const store=storeRef.current,sub=subscribeToRecoilValue$1(store,recoilValue,_state=>{Recoil_Tracing.trace("RecoilValue subscription fired",recoilValue.key,()=>{forceUpdate([])})},componentName);return Recoil_Tracing.trace("initial update on subscribing",recoilValue.key,()=>{store.getState().nextTree?store.getState().queuedComponentCallbacks_DEPRECATED.push(Recoil_Tracing.wrap(()=>{forceUpdate([])})):forceUpdate([])}),()=>sub.release(store)},[recoilValue,storeRef]),getRecoilValueAsLoadable$2(storeRef.current,recoilValue)}(recoilValue)}function useRecoilValue(recoilValue){const storeRef=useStoreRef$1();return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}function useSetRecoilState(recoilState){const storeRef=useStoreRef$1();return useCallback(newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)},[storeRef,recoilState])}function useTransactionSubscription(callback){const storeRef=useStoreRef$1();useEffect$1(()=>storeRef.current.subscribeToTransactions(callback).release,[callback,storeRef])}function externallyVisibleAtomValuesInState(state){const atomValues=state.atomValues,persistedAtomContentsValues=Recoil_mapMap(Recoil_filterMap(atomValues,(v,k)=>{const persistence=getNode$2(k).persistence_UNSTABLE;return null!=persistence&&"none"!==persistence.type&&"hasValue"===v.state}),v=>v.contents);return Recoil_mergeMaps(state.nonvalidatedAtoms,persistedAtomContentsValues)}function useGotoRecoilSnapshot(){const storeRef=useStoreRef$1();return useCallback(snapshot=>{var _storeState$nextTree;const storeState=storeRef.current.getState(),prev=null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree,next=snapshot.getStore_INTERNAL().getState().currentTree;batchUpdates$1(()=>{const keysToUpdate=new Set;for(const keys of[prev.atomValues.keys(),next.atomValues.keys()])for(const key of keys){var _prev$atomValues$get,_next$atomValues$get;(null===(_prev$atomValues$get=prev.atomValues.get(key))||void 0===_prev$atomValues$get?void 0:_prev$atomValues$get.contents)!==(null===(_next$atomValues$get=next.atomValues.get(key))||void 0===_next$atomValues$get?void 0:_next$atomValues$get.contents)&&getNode$2(key).shouldRestoreFromSnapshots&&keysToUpdate.add(key)}keysToUpdate.forEach(key=>{setRecoilValueLoadable$1(storeRef.current,new AbstractRecoilValue$2(key),next.atomValues.has(key)?Recoil_nullthrows(next.atomValues.get(key)):DEFAULT_VALUE$2)}),storeRef.current.replaceState(state=>({...state,stateID:snapshot.getID_INTERNAL()}))})},[storeRef])}class Sentinel{}const SENTINEL=new Sentinel;var Recoil_Hooks={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useGotoRecoilSnapshot:useGotoRecoilSnapshot,useRecoilCallback:function(fn,deps){const storeRef=useStoreRef$1(),gotoSnapshot=useGotoRecoilSnapshot();return useCallback((...args)=>{const snapshot=cloneSnapshot$1(storeRef.current);function set(recoilState,newValueOrUpdater){setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}function reset(recoilState){setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}let ret=SENTINEL;return batchUpdates$1(()=>{ret=fn({set:set,reset:reset,snapshot:snapshot,gotoSnapshot:gotoSnapshot})(...args)}),ret instanceof Sentinel&&Recoil_invariant(!1),ret},null!=deps?[...deps,storeRef]:void 0)},useRecoilInterface:function(){const storeRef=useStoreRef$1(),[_,forceUpdate]=useState$1([]),recoilValuesUsed=useRef$1(new Set);recoilValuesUsed.current=new Set;const previousSubscriptions=useRef$1(new Set),subscriptions=useRef$1(new Map),unsubscribeFrom=useCallback(key=>{const sub=subscriptions.current.get(key);sub&&(sub.release(storeRef.current),subscriptions.current.delete(key))},[storeRef,subscriptions]),componentName=useComponentName();return useEffect$1(()=>{const store=storeRef.current;function updateState(_state,key){subscriptions.current.has(key)&&forceUpdate([])}Recoil_differenceSets(recoilValuesUsed.current,previousSubscriptions.current).forEach(key=>{if(subscriptions.current.has(key))return;const sub=subscribeToRecoilValue$1(store,new AbstractRecoilValue$2(key),state=>{Recoil_Tracing.trace("RecoilValue subscription fired",key,()=>{updateState(0,key)})},componentName);subscriptions.current.set(key,sub),Recoil_Tracing.trace("initial update on subscribing",key,()=>{store.getState().nextTree?store.getState().queuedComponentCallbacks_DEPRECATED.push(Recoil_Tracing.wrap(()=>{updateState(store.getState(),key)})):updateState(store.getState(),key)})}),Recoil_differenceSets(previousSubscriptions.current,recoilValuesUsed.current).forEach(key=>{unsubscribeFrom(key)}),previousSubscriptions.current=recoilValuesUsed.current}),useEffect$1(()=>{const subs=subscriptions.current;return()=>subs.forEach((_,key)=>unsubscribeFrom(key))},[unsubscribeFrom]),useMemo$1(()=>{function useSetRecoilState(recoilState){return newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}}function useRecoilValueLoadable(recoilValue){return recoilValuesUsed.current.has(recoilValue.key)||(recoilValuesUsed.current=setByAddingToSet$2(recoilValuesUsed.current,recoilValue.key)),getRecoilValueAsLoadable$2(storeRef.current,recoilValue)}function useRecoilValue(recoilValue){return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}return{getRecoilValue:useRecoilValue,getRecoilValueLoadable:useRecoilValueLoadable,getRecoilState:function(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},getRecoilStateLoadable:function(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},getSetRecoilState:useSetRecoilState,getResetRecoilState:function(recoilState){return()=>setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}}},[recoilValuesUsed,storeRef])},useRecoilSnapshot:function(){const storeRef=useStoreRef$1(),[snapshot,setSnapshot]=useState$1(()=>cloneSnapshot$1(storeRef.current));return useTransactionSubscription(useCallback(store=>setSnapshot(cloneSnapshot$1(store)),[])),snapshot},useRecoilState:function(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},useRecoilStateLoadable:function(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},useRecoilTransactionObserver:function(callback){useTransactionSubscription(useCallback(store=>{callback({snapshot:cloneSnapshot$1(store,"current"),previousSnapshot:cloneSnapshot$1(store,"previous")})},[callback]))},useRecoilValue:useRecoilValue,useRecoilValueLoadable:useRecoilValueLoadable,useResetRecoilState:function(recoilState){const storeRef=useStoreRef$1();return useCallback(()=>{setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)},[storeRef,recoilState])},useSetRecoilState:useSetRecoilState,useSetUnvalidatedAtomValues:function(){const storeRef=useStoreRef$1();return(values,transactionMetadata={})=>{batchUpdates$1(()=>{storeRef.current.addTransactionMetadata(transactionMetadata),values.forEach((value,key)=>setUnvalidatedRecoilValue$1(storeRef.current,new AbstractRecoilValue$2(key),value))})}},useTransactionObservation_DEPRECATED:function(callback){useTransactionSubscription(useCallback(store=>{let previousTree=store.getState().previousTree;const currentTree=store.getState().currentTree;previousTree||(previousTree=store.getState().currentTree);const atomValues=externallyVisibleAtomValuesInState(currentTree),previousAtomValues=externallyVisibleAtomValuesInState(previousTree),atomInfo=Recoil_mapMap(nodes$1,node=>{var _node$persistence_UNS,_node$persistence_UNS2,_node$persistence_UNS3,_node$persistence_UNS4;return{persistence_UNSTABLE:{type:null!==(_node$persistence_UNS=null===(_node$persistence_UNS2=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS2?void 0:_node$persistence_UNS2.type)&&void 0!==_node$persistence_UNS?_node$persistence_UNS:"none",backButton:null!==(_node$persistence_UNS3=null===(_node$persistence_UNS4=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS4?void 0:_node$persistence_UNS4.backButton)&&void 0!==_node$persistence_UNS3&&_node$persistence_UNS3}}}),modifiedAtoms=Recoil_filterSet(currentTree.dirtyAtoms,k=>atomValues.has(k)||previousAtomValues.has(k));callback({atomValues:atomValues,previousAtomValues:previousAtomValues,atomInfo:atomInfo,modifiedAtoms:modifiedAtoms,transactionMetadata:{...currentTree.transactionMetadata}})},[callback]))},useTransactionSubscription_DEPRECATED:useTransactionSubscription};const{useMemo:useMemo$2}=react,{RecoilRoot:RecoilRoot$1,useStoreRef:useStoreRef$2}=Recoil_RecoilRoot_react;var Recoil_useRecoilBridgeAcrossReactRoots=function(){const store=useStoreRef$2().current;return useMemo$2(()=>function({children:children}){return react.createElement(RecoilRoot$1,{store_INTERNAL:store},children)},[store])};var Recoil_isPromise=function(p){return!!p&&"function"==typeof p.then};const loadableAccessors={getValue(){if("hasValue"!==this.state)throw this.contents;return this.contents},toPromise(){return"hasValue"===this.state?Promise.resolve(this.contents):"hasError"===this.state?Promise.reject(this.contents):this.contents},valueMaybe(){return"hasValue"===this.state?this.contents:void 0},valueOrThrow(){if("hasValue"!==this.state)throw new Error(`Loadable expected value, but in "${this.state}" state`);return this.contents},errorMaybe(){return"hasError"===this.state?this.contents:void 0},errorOrThrow(){if("hasError"!==this.state)throw new Error(`Loadable expected error, but in "${this.state}" state`);return this.contents},promiseMaybe(){return"loading"===this.state?this.contents:void 0},promiseOrThrow(){if("loading"!==this.state)throw new Error(`Loadable expected promise, but in "${this.state}" state`);return this.contents},map(map){if("hasError"===this.state)return this;if("hasValue"===this.state)try{const next=map(this.contents);return Recoil_isPromise(next)?loadableWithPromise(next):loadableWithValue(next)}catch(e){return Recoil_isPromise(e)?loadableWithPromise(e.next(()=>map(this.contents))):loadableWithError(e)}if("loading"===this.state)return loadableWithPromise(this.contents.then(map).catch(e=>{if(Recoil_isPromise(e))return e.then(()=>map(this.contents));throw e}));throw new Error("Invalid Loadable state")}};function loadableWithValue(value){return Object.freeze({state:"hasValue",contents:value,...loadableAccessors})}function loadableWithError(error){return Object.freeze({state:"hasError",contents:error,...loadableAccessors})}function loadableWithPromise(promise){return Object.freeze({state:"loading",contents:promise,...loadableAccessors})}var Recoil_Loadable={loadableWithValue:loadableWithValue,loadableWithError:loadableWithError,loadableWithPromise:loadableWithPromise,loadableLoading:function(){return loadableWithPromise(new Promise(()=>{}))},loadableAll:function(inputs){return inputs.every(i=>"hasValue"===i.state)?loadableWithValue(inputs.map(i=>i.contents)):inputs.some(i=>"hasError"===i.state)?loadableWithError(Recoil_nullthrows(inputs.find(i=>"hasError"===i.state),"Invalid loadable passed to loadableAll").contents):loadableWithPromise(Recoil_gkx_1("recoil_async_selector_refactor")?Promise.all(inputs.map(i=>i.contents)).then(value=>({value:value})):Promise.all(inputs.map(i=>i.contents)))}};const LEAF=Symbol("ArrayKeyedMap"),emptyMap=new Map;class ArrayKeyedMap{constructor(existing){if(this._base=new Map,existing instanceof ArrayKeyedMap)for(const[k,v]of existing.entries())this.set(k,v);else if(existing)for(const[k,v]of existing)this.set(k,v);return this}get(key){const ks=Array.isArray(key)?key:[key];let map=this._base;return ks.forEach(k=>{var _map$get;map=null!==(_map$get=map.get(k))&&void 0!==_map$get?_map$get:emptyMap}),void 0===map?void 0:map.get(LEAF)}set(key,value){const ks=Array.isArray(key)?key:[key];let map=this._base,next=map;return ks.forEach(k=>{next=map.get(k),next||(next=new Map,map.set(k,next)),map=next}),next.set(LEAF,value),this}delete(key){const ks=Array.isArray(key)?key:[key];let map=this._base,next=map;return ks.forEach(k=>{next=map.get(k),next||(next=new Map,map.set(k,next)),map=next}),next.delete(LEAF),this}entries(){const answer=[];return function recurse(level,prefix){level.forEach((v,k)=>{k===LEAF?answer.push([prefix,v]):recurse(v,prefix.concat(k))})}(this._base,[]),answer.values()}toBuiltInMap(){return new Map(this.entries())}}var Recoil_ArrayKeyedMap=ArrayKeyedMap;var Recoil_cacheWithReferenceEquality=function(){return new Recoil_ArrayKeyedMap};var Recoil_PerformanceTimings={startPerfBlock:function(_id){return()=>null}};const{loadableWithError:loadableWithError$1,loadableWithPromise:loadableWithPromise$1,loadableWithValue:loadableWithValue$1}=Recoil_Loadable,{getNodeLoadable:getNodeLoadable$2,peekNodeLoadable:peekNodeLoadable$2,setNodeValue:setNodeValue$3}=Recoil_FunctionalCore,{addToDependencyMap:addToDependencyMap$1,mergeDepsIntoDependencyMap:mergeDepsIntoDependencyMap$1,saveDependencyMapToStore:saveDependencyMapToStore$3}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$3,RecoilValueNotReady:RecoilValueNotReady$2,registerNode:registerNode$1}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$3}=Recoil_RecoilValue$1,{getRecoilValueAsLoadable:getRecoilValueAsLoadable$3,isRecoilValue:isRecoilValue$2,setRecoilValueLoadable:setRecoilValueLoadable$2}=Recoil_RecoilValueInterface,{startPerfBlock:startPerfBlock$1}=Recoil_PerformanceTimings,emptySet$1=Object.freeze(new Set);function cacheKeyFromDepValues(depValues){const answer=[];for(const key of Array.from(depValues.keys()).sort()){const loadable=Recoil_nullthrows(depValues.get(key));answer.push(key),answer.push(loadable.state),answer.push(loadable.contents)}return answer}const waitingStores=new Map;var Recoil_selector=function(options){const{key:key,get:get,cacheImplementation_UNSTABLE:cacheImplementation}=options,set=null!=options.set?options.set:void 0;let cache=null!=cacheImplementation?cacheImplementation:Recoil_cacheWithReferenceEquality();function initSelector(store){store.getState().knownSelectors.add(key)}function letStoreBeNotifiedWhenAsyncSettles(store,loadable){if("loading"===loadable.state){let stores=waitingStores.get(loadable);void 0===stores&&waitingStores.set(loadable,stores=new Set),stores.add(store)}}function notifyStoresOfSettledAsync(originalLoadable,newLoadable){const stores=waitingStores.get(originalLoadable);if(void 0!==stores){for(const store of stores)setRecoilValueLoadable$2(store,new AbstractRecoilValue$3(key),newLoadable);waitingStores.delete(originalLoadable)}}function getFromCacheOrEvaluate(store,state){var _store$getGraph$nodeD;const dependencyMap=new Map,currentDeps=null!==(_store$getGraph$nodeD=store.getGraph(state.version).nodeDeps.get(key))&&void 0!==_store$getGraph$nodeD?_store$getGraph$nodeD:emptySet$1,cacheKey=cacheKeyFromDepValues(new Map(Array.from(currentDeps).sort().map(depKey=>{const[deps,loadable]=getNodeLoadable$2(store,state,depKey);return mergeDepsIntoDependencyMap$1(deps,dependencyMap),saveDependencyMapToStore$3(dependencyMap,store,state.version),[depKey,loadable]}))),cached=cache.get(cacheKey);if(null!=cached)return letStoreBeNotifiedWhenAsyncSettles(store,cached),[dependencyMap,cached];const[deps,loadable,newDepValues]=function(store,state){const endPerfBlock=startPerfBlock$1(key),depValues=new Map,dependencyMap=new Map;function getRecoilValue({key:depKey}){addToDependencyMap$1(key,depKey,dependencyMap);const[deps,loadable]=getNodeLoadable$2(store,state,depKey);if(depValues.set(depKey,loadable),mergeDepsIntoDependencyMap$1(deps,dependencyMap),saveDependencyMapToStore$3(dependencyMap,store,state.version),"hasValue"===loadable.state)return loadable.contents;throw loadable.contents}try{const output=get({get:getRecoilValue}),result=isRecoilValue$2(output)?getRecoilValue(output):output;let loadable;return Recoil_isPromise(result)?loadable=loadableWithPromise$1(result.finally(endPerfBlock)):(endPerfBlock(),loadable=loadableWithValue$1(result)),[dependencyMap,loadable,depValues]}catch(errorOrDepPromise){let loadable;return void 0!==errorOrDepPromise.then?loadable=loadableWithPromise$1(errorOrDepPromise.then(()=>{const loadable=getRecoilValueAsLoadable$3(store,new AbstractRecoilValue$3(key));if("hasError"===loadable.state)throw loadable.contents;return loadable.contents}).finally(endPerfBlock)):(endPerfBlock(),loadable=loadableWithError$1(errorOrDepPromise)),[dependencyMap,loadable,depValues]}}(store,state);mergeDepsIntoDependencyMap$1(deps,dependencyMap),saveDependencyMapToStore$3(dependencyMap,store,state.version);const newCacheKey=cacheKeyFromDepValues(newDepValues);return letStoreBeNotifiedWhenAsyncSettles(store,loadable),function(cacheKey,loadable){"loading"!==loadable.state||loadable.contents.then(result=>{const newLoadable=loadableWithValue$1(result);return cache=cache.set(cacheKey,newLoadable),notifyStoresOfSettledAsync(loadable,newLoadable),result}).catch(error=>{if(Recoil_isPromise(error))return error;const newLoadable=loadableWithError$1(error);return cache=cache.set(cacheKey,newLoadable),notifyStoresOfSettledAsync(loadable,newLoadable),error}),cache=cache.set(cacheKey,loadable)}(newCacheKey,loadable),[dependencyMap,loadable]}function myPeek(store,state){var _store$getGraph$nodeD2;const currentDeps=null!==(_store$getGraph$nodeD2=store.getGraph(state.version).nodeDeps.get(key))&&void 0!==_store$getGraph$nodeD2?_store$getGraph$nodeD2:emptySet$1,depValues=new Map(Array.from(currentDeps).sort().map(depKey=>[depKey,peekNodeLoadable$2(store,state,depKey)])),cacheDepValues=new Map;for(const[depKey,depValue]of depValues.entries()){if(null==depValue)return;cacheDepValues.set(depKey,depValue)}const cacheKey=cacheKeyFromDepValues(cacheDepValues);return cache.get(cacheKey)}function myGet(store,state){return initSelector(store),getFromCacheOrEvaluate(store,state)}if(null!=set){return registerNode$1({key:key,peek:myPeek,get:myGet,set:function(store,state,newValue){initSelector(store);const dependencyMap=new Map,writes=new Map;function getRecoilValue({key:key}){const[deps,loadable]=getNodeLoadable$2(store,state,key);if(mergeDepsIntoDependencyMap$1(deps,dependencyMap),"hasValue"===loadable.state)return loadable.contents;throw"loading"===loadable.state?new RecoilValueNotReady$2(key):loadable.contents}function setRecoilState(recoilState,valueOrUpdater){const newValue="function"==typeof valueOrUpdater?valueOrUpdater(getRecoilValue(recoilState)):valueOrUpdater,[deps,upstreamWrites]=setNodeValue$3(store,state,recoilState.key,newValue);mergeDepsIntoDependencyMap$1(deps,dependencyMap),upstreamWrites.forEach((v,k)=>writes.set(k,v))}return set({set:setRecoilState,get:getRecoilValue,reset:function(recoilState){setRecoilState(recoilState,DEFAULT_VALUE$3)}},newValue),[dependencyMap,writes]},cleanUp:()=>{},dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})}return registerNode$1({key:key,peek:myPeek,get:myGet,cleanUp:()=>{},dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})};const{loadableWithError:loadableWithError$2,loadableWithPromise:loadableWithPromise$2,loadableWithValue:loadableWithValue$2}=Recoil_Loadable,{DEFAULT_VALUE:DEFAULT_VALUE$4,DefaultValue:DefaultValue$2,registerNode:registerNode$2}=Recoil_Node,{isRecoilValue:isRecoilValue$3}=Recoil_RecoilValue$1,{markRecoilValueModified:markRecoilValueModified$1,setRecoilValue:setRecoilValue$3,setRecoilValueLoadable:setRecoilValueLoadable$3}=Recoil_RecoilValueInterface;function baseAtom(options){const{key:key,persistence_UNSTABLE:persistence}=options;let defaultLoadable=Recoil_isPromise(options.default)?loadableWithPromise$2(options.default.then(value=>(defaultLoadable=loadableWithValue$2(value),value)).catch(error=>{throw defaultLoadable=loadableWithError$2(error),error})):loadableWithValue$2(options.default),cachedAnswerForUnvalidatedValue=void 0;const cleanupEffectsByStore=new Map;function initAtom(store,initState,trigger){if(store.getState().knownAtoms.has(key))return;if(store.getState().knownAtoms.add(key),"loading"===defaultLoadable.state){function notifyDefaultSubscribers(){var _store$getState$nextT3;(null!==(_store$getState$nextT3=store.getState().nextTree)&&void 0!==_store$getState$nextT3?_store$getState$nextT3:store.getState().currentTree).atomValues.has(key)||markRecoilValueModified$1(store,node)}defaultLoadable.contents.then(notifyDefaultSubscribers).catch(notifyDefaultSubscribers)}let initValue=DEFAULT_VALUE$4;if(null!=options.effects_UNSTABLE){let duringInit=!0;function setSelf(valueOrUpdater){if(duringInit){const currentValue=initValue instanceof DefaultValue$2||Recoil_isPromise(initValue)?"hasValue"===defaultLoadable.state?defaultLoadable.contents:DEFAULT_VALUE$4:initValue;initValue="function"==typeof valueOrUpdater?valueOrUpdater(currentValue):valueOrUpdater}else{if(Recoil_isPromise(valueOrUpdater))throw new Error("Setting atoms to async values is not implemented.");setRecoilValue$3(store,node,valueOrUpdater)}}const resetSelf=()=>setSelf(DEFAULT_VALUE$4);function onSet(handler){store.subscribeToTransactions(currentStore=>{let{currentTree:currentTree,previousTree:previousTree}=currentStore.getState();previousTree||(previousTree=currentTree);const newLoadable=currentTree.atomValues.get(key);if(null==newLoadable||"hasValue"===newLoadable.state){var _previousTree$atomVal;const newValue=null!=newLoadable?newLoadable.contents:DEFAULT_VALUE$4,oldLoadable=null!==(_previousTree$atomVal=previousTree.atomValues.get(key))&&void 0!==_previousTree$atomVal?_previousTree$atomVal:defaultLoadable,oldValue="hasValue"===oldLoadable.state?oldLoadable.contents:DEFAULT_VALUE$4;handler(newValue,oldValue)}},key)}for(const effect of null!==(_options$effects_UNST=options.effects_UNSTABLE)&&void 0!==_options$effects_UNST?_options$effects_UNST:[]){var _options$effects_UNST;const cleanup=effect({node:node,trigger:trigger,setSelf:setSelf,resetSelf:resetSelf,onSet:onSet});null!=cleanup&&cleanupEffectsByStore.set(store,cleanup)}duringInit=!1}initValue instanceof DefaultValue$2||initState.atomValues.set(key,Recoil_isPromise(initValue)?loadableWithPromise$2(function(store,promise){const wrappedPromise=promise.then(value=>{var _store$getState$nextT,_state$atomValues$get;return(null===(_state$atomValues$get=(null!==(_store$getState$nextT=store.getState().nextTree)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get?void 0:_state$atomValues$get.contents)===wrappedPromise&&setRecoilValue$3(store,node,value),value}).catch(error=>{var _store$getState$nextT2,_state$atomValues$get2;throw(null===(_state$atomValues$get2=(null!==(_store$getState$nextT2=store.getState().nextTree)&&void 0!==_store$getState$nextT2?_store$getState$nextT2:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get2?void 0:_state$atomValues$get2.contents)===wrappedPromise&&setRecoilValueLoadable$3(store,node,loadableWithError$2(error)),error});return wrappedPromise}(store,initValue)):loadableWithValue$2(initValue))}const node=registerNode$2({key:key,peek:function(_store,state){var _ref,_state$atomValues$get3,_cachedAnswerForUnval;return null!==(_ref=null!==(_state$atomValues$get3=state.atomValues.get(key))&&void 0!==_state$atomValues$get3?_state$atomValues$get3:null===(_cachedAnswerForUnval=cachedAnswerForUnvalidatedValue)||void 0===_cachedAnswerForUnval?void 0:_cachedAnswerForUnval[1])&&void 0!==_ref?_ref:defaultLoadable},get:function(store,state){if(initAtom(store,state,"get"),state.atomValues.has(key))return[new Map,Recoil_nullthrows(state.atomValues.get(key))];if(state.nonvalidatedAtoms.has(key)){if(null!=cachedAnswerForUnvalidatedValue)return cachedAnswerForUnvalidatedValue;if(null==persistence)return[new Map,defaultLoadable];const nonvalidatedValue=state.nonvalidatedAtoms.get(key),validatorResult=persistence.validator(nonvalidatedValue,DEFAULT_VALUE$4),validatedValueLoadable=validatorResult instanceof DefaultValue$2?defaultLoadable:loadableWithValue$2(validatorResult);return cachedAnswerForUnvalidatedValue=[new Map,validatedValueLoadable],cachedAnswerForUnvalidatedValue}return[new Map,defaultLoadable]},set:function(store,state,newValue){if(initAtom(store,state,"set"),state.atomValues.has(key)){const existing=Recoil_nullthrows(state.atomValues.get(key));if("hasValue"===existing.state&&newValue===existing.contents)return[new Map,new Map]}else if(!state.nonvalidatedAtoms.has(key)&&newValue instanceof DefaultValue$2)return[new Map,new Map];return cachedAnswerForUnvalidatedValue=void 0,[new Map,(new Map).set(key,loadableWithValue$2(newValue))]},cleanUp:function(store){var _cleanupEffectsByStor;null===(_cleanupEffectsByStor=cleanupEffectsByStore.get(store))||void 0===_cleanupEffectsByStor||_cleanupEffectsByStor(),cleanupEffectsByStore.delete(store)},invalidate:function(){cachedAnswerForUnvalidatedValue=void 0},dangerouslyAllowMutability:options.dangerouslyAllowMutability,persistence_UNSTABLE:options.persistence_UNSTABLE?{type:options.persistence_UNSTABLE.type,backButton:options.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0});return node}function atom(options){const{default:optionsDefault,...restOptions}=options;return isRecoilValue$3(optionsDefault)?function(options){const base=atom({...options,default:DEFAULT_VALUE$4,persistence_UNSTABLE:void 0===options.persistence_UNSTABLE?void 0:{...options.persistence_UNSTABLE,validator:storedValue=>storedValue instanceof DefaultValue$2?storedValue:Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue,DEFAULT_VALUE$4)},effects_UNSTABLE:options.effects_UNSTABLE});return Recoil_selector({key:options.key+"__withFallback",get:({get:get})=>{const baseValue=get(base);return baseValue instanceof DefaultValue$2?options.default:baseValue},set:({set:set},newValue)=>set(base,newValue),dangerouslyAllowMutability:options.dangerouslyAllowMutability})}({...restOptions,default:optionsDefault}):baseAtom({...restOptions,default:optionsDefault})}var Recoil_atom=atom;var Recoil_stableStringify=function(x,opt={allowFunctions:!1}){return function stringify(x,opt,key){if("string"==typeof x&&!x.includes('"')&&!x.includes("\\"))return`"${x}"`;switch(typeof x){case"undefined":return"";case"boolean":return x?"true":"false";case"number":case"symbol":return String(x);case"string":return JSON.stringify(x);case"function":if(!0!==(null==opt?void 0:opt.allowFunctions))throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${x.name})__`}if(null===x)return"null";var _JSON$stringify;if("object"!=typeof x)return null!==(_JSON$stringify=JSON.stringify(x))&&void 0!==_JSON$stringify?_JSON$stringify:"";if(Recoil_isPromise(x))return"__PROMISE__";if(Array.isArray(x))return`[${x.map((v,i)=>stringify(v,opt,i.toString()))}]`;if("function"==typeof x.toJSON)return stringify(x.toJSON(key),opt,key);if(x instanceof Map){const obj={};for(const[k,v]of x)obj["string"==typeof k?k:stringify(k,opt)]=v;return stringify(obj,opt,key)}return x instanceof Set?stringify(Array.from(x).sort((a,b)=>stringify(a,opt).localeCompare(stringify(b,opt))),opt,key):null!=x[Symbol.iterator]&&"function"==typeof x[Symbol.iterator]?stringify(Array.from(x),opt,key):`{${Object.keys(x).filter(key=>void 0!==x[key]).sort().map(key=>`${stringify(key,opt)}:${stringify(x[key],opt,key)}`).join(",")}}`}(x,opt)};var Recoil_cacheWithValueEquality=function(){const map=new Map,cache={get:key=>map.get(Recoil_stableStringify(key)),set:(key,value)=>(map.set(Recoil_stableStringify(key),value),cache),map:map};return cache};let nextIndex=0;var Recoil_selectorFamily=function(options){var _options$cacheImpleme,_options$cacheImpleme2;let selectorCache=null!==(_options$cacheImpleme=null===(_options$cacheImpleme2=options.cacheImplementationForParams_UNSTABLE)||void 0===_options$cacheImpleme2?void 0:_options$cacheImpleme2.call(options))&&void 0!==_options$cacheImpleme?_options$cacheImpleme:Recoil_cacheWithValueEquality();return params=>{var _stableStringify,_options$cacheImpleme3;const cachedSelector=selectorCache.get(params);if(null!=cachedSelector)return cachedSelector;const myKey=`${options.key}__selectorFamily/${null!==(_stableStringify=Recoil_stableStringify(params,{allowFunctions:!0}))&&void 0!==_stableStringify?_stableStringify:"void"}/${nextIndex++}`,myGet=callbacks=>options.get(params)(callbacks),myCacheImplementation=null===(_options$cacheImpleme3=options.cacheImplementation_UNSTABLE)||void 0===_options$cacheImpleme3?void 0:_options$cacheImpleme3.call(options);let newSelector;if(null!=options.set){const set=options.set;newSelector=Recoil_selector({key:myKey,get:myGet,set:(callbacks,newValue)=>set(params)(callbacks,newValue),cacheImplementation_UNSTABLE:myCacheImplementation,dangerouslyAllowMutability:options.dangerouslyAllowMutability})}else newSelector=Recoil_selector({key:myKey,get:myGet,cacheImplementation_UNSTABLE:myCacheImplementation,dangerouslyAllowMutability:options.dangerouslyAllowMutability});return selectorCache=selectorCache.set(params,newSelector),newSelector}};const{DEFAULT_VALUE:DEFAULT_VALUE$5,DefaultValue:DefaultValue$3}=Recoil_Node;var Recoil_atomFamily=function(options){let atomCache=Recoil_cacheWithValueEquality();const legacyAtomOptions={key:options.key,default:DEFAULT_VALUE$5,persistence_UNSTABLE:options.persistence_UNSTABLE};let legacyAtom;legacyAtom=Recoil_atom(legacyAtomOptions);const atomFamilyDefault=Recoil_selectorFamily({key:options.key+"__atomFamily/Default",get:param=>({get:get})=>{const legacyValue=get("function"==typeof legacyAtom?legacyAtom(param):legacyAtom);return legacyValue instanceof DefaultValue$3?"function"==typeof options.default?options.default(param):options.default:legacyValue},dangerouslyAllowMutability:options.dangerouslyAllowMutability});return params=>{var _stableStringify;const cachedAtom=atomCache.get(params);if(null!=cachedAtom)return cachedAtom;const newAtom=Recoil_atom({...options,key:`${options.key}__${null!==(_stableStringify=Recoil_stableStringify(params))&&void 0!==_stableStringify?_stableStringify:"void"}`,default:atomFamilyDefault(params),effects_UNSTABLE:"function"==typeof options.effects_UNSTABLE?options.effects_UNSTABLE(params):options.effects_UNSTABLE});return atomCache=atomCache.set(params,newAtom),newAtom}};const constantSelector=Recoil_selectorFamily({key:"__constant",get:constant=>()=>constant,cacheImplementationForParams_UNSTABLE:Recoil_cacheWithReferenceEquality});var Recoil_constSelector=function(constant){return constantSelector(constant)};const throwingSelector=Recoil_selectorFamily({key:"__error",get:message=>()=>{throw new Error(message)},cacheImplementationForParams_UNSTABLE:Recoil_cacheWithReferenceEquality});var Recoil_errorSelector=function(message){return throwingSelector(message)};var Recoil_readOnlySelector=function(atom){return atom};const{loadableWithError:loadableWithError$3,loadableWithPromise:loadableWithPromise$3,loadableWithValue:loadableWithValue$3}=Recoil_Loadable;function concurrentRequests(getRecoilValue,deps){const results=Array(deps.length).fill(void 0),exceptions=Array(deps.length).fill(void 0);for(const[i,dep]of deps.entries())try{results[i]=getRecoilValue(dep)}catch(e){exceptions[i]=e}return[results,exceptions]}function isError(exp){return null!=exp&&!Recoil_isPromise(exp)}function unwrapDependencies(dependencies){return Array.isArray(dependencies)?dependencies:Object.getOwnPropertyNames(dependencies).map(key=>dependencies[key])}function getValueFromLoadablePromiseResult(result){return result.hasOwnProperty("value")?result.value:result}function wrapResults(dependencies,results){return Array.isArray(dependencies)?results:Object.getOwnPropertyNames(dependencies).reduce((out,key,idx)=>({...out,[key]:results[idx]}),{})}function wrapLoadables(dependencies,results,exceptions){return wrapResults(dependencies,exceptions.map((exception,idx)=>null==exception?loadableWithValue$3(results[idx]):Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception)))}var Recoil_WaitFor={waitForNone:Recoil_selectorFamily({key:"__waitForNone",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return wrapLoadables(dependencies,results,exceptions)}}),waitForAny:Recoil_selectorFamily({key:"__waitForAny",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);if(exceptions.some(exp=>null==exp))return wrapLoadables(dependencies,results,exceptions);if(exceptions.every(isError))throw exceptions.find(isError);if(Recoil_gkx_1("recoil_async_selector_refactor"))return new Promise((resolve,reject)=>{for(const[i,exp]of exceptions.entries())Recoil_isPromise(exp)&&exp.then(result=>{results[i]=getValueFromLoadablePromiseResult(result),exceptions[i]=null,resolve(wrapLoadables(dependencies,results,exceptions))}).catch(error=>{exceptions[i]=error,exceptions.every(isError)&&reject(exceptions[0])})});throw new Promise((resolve,reject)=>{for(const[i,exp]of exceptions.entries())Recoil_isPromise(exp)&&exp.then(result=>{results[i]=result,exceptions[i]=null,resolve(wrapLoadables(dependencies,results,exceptions))}).catch(error=>{exceptions[i]=error,exceptions.every(isError)&&reject(exceptions[0])})})}}),waitForAll:Recoil_selectorFamily({key:"__waitForAll",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);if(exceptions.every(exp=>null==exp))return wrapResults(dependencies,results);const error=exceptions.find(isError);if(null!=error)throw error;if(Recoil_gkx_1("recoil_async_selector_refactor"))return Promise.all(exceptions).then(results=>wrapResults(dependencies,results.map(getValueFromLoadablePromiseResult)));throw Promise.all(exceptions).then(results=>wrapResults(dependencies,results))}}),noWait:Recoil_selectorFamily({key:"__noWait",get:dependency=>({get:get})=>{try{return loadableWithValue$3(get(dependency))}catch(exception){return Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception)}}})};const{DefaultValue:DefaultValue$4}=Recoil_Node,{RecoilRoot:RecoilRoot$2}=Recoil_RecoilRoot_react,{isRecoilValue:isRecoilValue$4}=Recoil_RecoilValue$1,{useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilCallback:useRecoilCallback$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useRecoilTransactionObserver:useRecoilTransactionObserver$1,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useResetRecoilState:useResetRecoilState$1,useSetRecoilState:useSetRecoilState$1,useSetUnvalidatedAtomValues:useSetUnvalidatedAtomValues$1,useTransactionObservation_DEPRECATED:useTransactionObservation_DEPRECATED$1}=Recoil_Hooks,{noWait:noWait$1,waitForAll:waitForAll$1,waitForAny:waitForAny$1,waitForNone:waitForNone$1}=Recoil_WaitFor,{batchUpdates:batchUpdates$2,setBatcher:setBatcher$1}=Recoil_batcher;var Recoil_index={DefaultValue:DefaultValue$4,RecoilRoot:RecoilRoot$2,useRecoilBridgeAcrossReactRoots_UNSTABLE:Recoil_useRecoilBridgeAcrossReactRoots,atom:Recoil_atom,selector:Recoil_selector,atomFamily:Recoil_atomFamily,selectorFamily:Recoil_selectorFamily,constSelector:Recoil_constSelector,errorSelector:Recoil_errorSelector,readOnlySelector:Recoil_readOnlySelector,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useSetRecoilState:useSetRecoilState$1,useResetRecoilState:useResetRecoilState$1,useRecoilCallback:useRecoilCallback$1,useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilTransactionObserver_UNSTABLE:useRecoilTransactionObserver$1,useTransactionObservation_UNSTABLE:useTransactionObservation_DEPRECATED$1,useSetUnvalidatedAtomValues_UNSTABLE:useSetUnvalidatedAtomValues$1,noWait:noWait$1,waitForNone:waitForNone$1,waitForAny:waitForAny$1,waitForAll:waitForAll$1,isRecoilValue:isRecoilValue$4,batchUpdates:batchUpdates$2,setBatcher:setBatcher$1},Recoil_index_1=Recoil_index.DefaultValue,Recoil_index_2=Recoil_index.RecoilRoot,Recoil_index_3=Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE,Recoil_index_4=Recoil_index.atom,Recoil_index_5=Recoil_index.selector,Recoil_index_6=Recoil_index.atomFamily,Recoil_index_7=Recoil_index.selectorFamily,Recoil_index_8=Recoil_index.constSelector,Recoil_index_9=Recoil_index.errorSelector,Recoil_index_10=Recoil_index.readOnlySelector,Recoil_index_11=Recoil_index.useRecoilValue,Recoil_index_12=Recoil_index.useRecoilValueLoadable,Recoil_index_13=Recoil_index.useRecoilState,Recoil_index_14=Recoil_index.useRecoilStateLoadable,Recoil_index_15=Recoil_index.useSetRecoilState,Recoil_index_16=Recoil_index.useResetRecoilState,Recoil_index_17=Recoil_index.useRecoilCallback,Recoil_index_18=Recoil_index.useGotoRecoilSnapshot,Recoil_index_19=Recoil_index.useRecoilSnapshot,Recoil_index_20=Recoil_index.useRecoilTransactionObserver_UNSTABLE,Recoil_index_21=Recoil_index.useTransactionObservation_UNSTABLE,Recoil_index_22=Recoil_index.useSetUnvalidatedAtomValues_UNSTABLE,Recoil_index_23=Recoil_index.noWait,Recoil_index_24=Recoil_index.waitForNone,Recoil_index_25=Recoil_index.waitForAny,Recoil_index_26=Recoil_index.waitForAll,Recoil_index_27=Recoil_index.isRecoilValue,Recoil_index_28=Recoil_index.batchUpdates,Recoil_index_29=Recoil_index.setBatcher;export default Recoil_index;export{Recoil_index_1 as DefaultValue,Recoil_index_2 as RecoilRoot,Recoil_index_4 as atom,Recoil_index_6 as atomFamily,Recoil_index_28 as batchUpdates,Recoil_index_8 as constSelector,Recoil_index_9 as errorSelector,Recoil_index_27 as isRecoilValue,Recoil_index_23 as noWait,Recoil_index_10 as readOnlySelector,Recoil_index_5 as selector,Recoil_index_7 as selectorFamily,Recoil_index_29 as setBatcher,Recoil_index_18 as useGotoRecoilSnapshot,Recoil_index_3 as useRecoilBridgeAcrossReactRoots_UNSTABLE,Recoil_index_17 as useRecoilCallback,Recoil_index_19 as useRecoilSnapshot,Recoil_index_13 as useRecoilState,Recoil_index_14 as useRecoilStateLoadable,Recoil_index_20 as useRecoilTransactionObserver_UNSTABLE,Recoil_index_11 as useRecoilValue,Recoil_index_12 as useRecoilValueLoadable,Recoil_index_16 as useResetRecoilState,Recoil_index_15 as useSetRecoilState,Recoil_index_22 as useSetUnvalidatedAtomValues_UNSTABLE,Recoil_index_21 as useTransactionObservation_UNSTABLE,Recoil_index_26 as waitForAll,Recoil_index_25 as waitForAny,Recoil_index_24 as waitForNone};
