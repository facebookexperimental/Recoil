"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[7902],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||s;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,r=new Array(s);r[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,r[1]=i;for(var c=2;c<s;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5281:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return d}});var a=n(7462),o=n(3366),s=(n(7294),n(3905)),r=["components"],i={title:"Testing"},l=void 0,c={unversionedId:"guides/testing",id:"guides/testing",title:"Testing",description:"Testing Recoil state inside of a React component",source:"@site/docs/guides/testing.md",sourceDirName:"guides",slug:"/guides/testing",permalink:"/docs/guides/testing",editUrl:"https://github.com/facebookexperimental/Recoil/edit/docs/docs/docs/guides/testing.md",tags:[],version:"current",frontMatter:{title:"Testing"},sidebar:"docs",previous:{title:"Atom Effects",permalink:"/docs/guides/atom-effects"},next:{title:"Dev Tools",permalink:"/docs/guides/dev-tools"}},u=[{value:"Testing Recoil state inside of a React component",id:"testing-recoil-state-inside-of-a-react-component",children:[{value:"Example: Form state modified by user",id:"example-form-state-modified-by-user",children:[{value:"Component",id:"component",children:[],level:4},{value:"Test",id:"test",children:[],level:4}],level:3}],level:2},{value:"Testing Recoil state with asynchronous queries inside of a React component",id:"testing-recoil-state-with-asynchronous-queries-inside-of-a-react-component",children:[{value:"Example: Title with data returned from asynchronous data query",id:"example-title-with-data-returned-from-asynchronous-data-query",children:[{value:"Component",id:"component-1",children:[],level:4},{value:"Test",id:"test-1",children:[],level:4}],level:3}],level:2},{value:"Testing Recoil state inside a Custom Hook",id:"testing-recoil-state-inside-a-custom-hook",children:[{value:"Example: React Hooks Testing Library",id:"example-react-hooks-testing-library",children:[{value:"State",id:"state",children:[],level:4},{value:"Hook",id:"hook",children:[],level:4},{value:"Test",id:"test-2",children:[],level:4}],level:3}],level:2},{value:"Testing Recoil state outside of React",id:"testing-recoil-state-outside-of-react",children:[{value:"Example: Jest unit testing selectors",id:"example-jest-unit-testing-selectors",children:[],level:3},{value:"Testing async selectors",id:"testing-async-selectors",children:[],level:3},{value:"Clearing all selector caches",id:"clearing-all-selector-caches",children:[],level:3}],level:2}],p={toc:u};function d(e){var t=e.components,n=(0,o.Z)(e,r);return(0,s.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"testing-recoil-state-inside-of-a-react-component"},"Testing Recoil state inside of a React component"),(0,s.kt)("p",null,"It can be helpful to test Recoil state when testing a component. You can compare the new state against expected values using this pattern. It uses a React functional component, ",(0,s.kt)("inlineCode",{parentName:"p"},"useRecoilValue")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"useEffect"),", to observe an ",(0,s.kt)("inlineCode",{parentName:"p"},"atom"),"/",(0,s.kt)("inlineCode",{parentName:"p"},"selector"),"'s changes and execute a callback every time the user performs an action that modifies the state."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"export const RecoilObserver = ({node, onChange}) => {\n  const value = useRecoilValue(node);\n  useEffect(() => onChange(value), [onChange, value]);\n  return null;\n};\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"strong"},"node")),": can be an atom or a selector."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"strong"},"onChange")),": this function will be called every time the state changes.")),(0,s.kt)("h3",{id:"example-form-state-modified-by-user"},"Example: Form state modified by user"),(0,s.kt)("h4",{id:"component"},"Component"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const nameState = atom({\n  key: 'nameAtom',\n  default: '',\n});\n\nfunction Form() {\n  const [name, setName] = useRecoilState(nameState);\n  return (\n    <form>\n      <input\n        data-testid=\"name_input\"\n        type=\"text\"\n        value={name}\n        onChange={event => setName(event.target.value)}\n      />\n    </form>\n  );\n}\n")),(0,s.kt)("h4",{id:"test"},"Test"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"describe('The form state should', () => {\n  test('change when the user enters a name.', () => {\n    const onChange = jest.fn();\n\n    render(\n      <RecoilRoot>\n        <RecoilObserver node={nameState} onChange={onChange} />\n        <Form />\n      </RecoilRoot>,\n    );\n\n    const component = screen.getByTestId('name_input');\n\n    fireEvent.change(component, {target: {value: 'Recoil'}});\n\n    expect(onChange).toHaveBeenCalledTimes(2);\n    expect(onChange).toHaveBeenCalledWith(''); // Initial state on render.\n    expect(onChange).toHaveBeenCalledWith('Recoil'); // New value on change.\n  });\n});\n")),(0,s.kt)("h2",{id:"testing-recoil-state-with-asynchronous-queries-inside-of-a-react-component"},"Testing Recoil state with asynchronous queries inside of a React component"),(0,s.kt)("p",null,"A common pattern for atoms is using asynchronous queries fetch the state of the atom, in a selector, or as part of an effect. This causes the component to be suspended. However, while testing, the component is suspended will not update in the DOM without acting. To test this scenario, we need a helper function:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"// act and advance jest timers\nfunction flushPromisesAndTimers(): Promise<void> {\n  return act(\n    () =>\n      new Promise(resolve => {\n        setTimeout(resolve, 100);\n        jest.runAllTimers();\n      }),\n  );\n}\n")),(0,s.kt)("h3",{id:"example-title-with-data-returned-from-asynchronous-data-query"},"Example: Title with data returned from asynchronous data query"),(0,s.kt)("h4",{id:"component-1"},"Component"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const getDefaultTitleAtomState = async () => {\n  const response = await fetch('https://example.com/returns/a/json');\n  return await response.json(); // { title: 'real title' };\n};\n\nconst titleState = atom({\n  key: 'titleState',\n  default: getDefaultTitleAtomState(),\n});\n\nfunction Title() {\n  const data = useRecoilValue(titleState);\n  return (\n    <div>\n      <h1>{data.title}</h1>\n    </div>\n  );\n}\n")),(0,s.kt)("h4",{id:"test-1"},"Test"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"describe('Title Component', () => {\n  test('display the title correctly', async () => {\n    const mockState = {title: 'test title'};\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        json: () => Promise.resolve(mockState),\n      }),\n    );\n\n    render(\n      <RecoilRoot>\n        <Suspense fallback={<div>loading...</div>}>\n          <Title />\n        </Suspense>\n      </RecoilRoot>,\n    );\n    await flushPromisesAndTimers();\n\n    expect(screen.getByText(mockState.title)).toBeInTheDocument();\n    expect(screen.getByText('loading...')).not.toBeInTheDocument();\n  });\n});\n")),(0,s.kt)("h2",{id:"testing-recoil-state-inside-a-custom-hook"},"Testing Recoil state inside a Custom Hook"),(0,s.kt)("p",null,"Sometimes it is convenient to write custom React hooks that rely on Recoil state. These need to be wrapped in a ",(0,s.kt)("inlineCode",{parentName:"p"},"<RecoilRoot>"),". The ",(0,s.kt)("a",{parentName:"p",href:"https://react-hooks-testing-library.com/"},"React Hooks Testing Library")," can help with this pattern."),(0,s.kt)("h3",{id:"example-react-hooks-testing-library"},"Example: React Hooks Testing Library"),(0,s.kt)("h4",{id:"state"},"State"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const countState = atom({\n  key: 'countAtom',\n  default: 0,\n});\n")),(0,s.kt)("h4",{id:"hook"},"Hook"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const useMyCustomHook = () => {\n  const [count, setCount] = useRecoilState(countState);\n  // Insert other Recoil state here...\n  // Insert other hook logic here...\n  return count;\n};\n")),(0,s.kt)("h4",{id:"test-2"},"Test"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"test('Test useMyCustomHook', () => {\n  const {result} = renderHook(() => useMyCustomHook(), {\n    wrapper: RecoilRoot,\n  });\n  expect(result.current).toEqual(0);\n});\n")),(0,s.kt)("h2",{id:"testing-recoil-state-outside-of-react"},"Testing Recoil state outside of React"),(0,s.kt)("p",null,"It can be useful to manipulate and evaluate Recoil selectors outside of a React context for testing. This can be done by working with a Recoil ",(0,s.kt)("a",{parentName:"p",href:"/docs/api-reference/core/Snapshot"},(0,s.kt)("inlineCode",{parentName:"a"},"Snapshot")),". You can build a fresh snapshot using ",(0,s.kt)("inlineCode",{parentName:"p"},"snapshot_UNSTABLE()")," and then use that ",(0,s.kt)("inlineCode",{parentName:"p"},"Snapshot")," to evaluate selectors for testing."),(0,s.kt)("h3",{id:"example-jest-unit-testing-selectors"},"Example: Jest unit testing selectors"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const numberState = atom({key: 'Number', default: 0});\n\nconst multipliedState = selector({\n  key: 'MultipliedNumber',\n  get: ({get}) => get(numberState) * 100,\n});\n\ntest('Test multipliedState', () => {\n  const initialSnapshot = snapshot_UNSTABLE();\n  expect(initialSnapshot.getLoadable(multipliedState).valueOrThrow()).toBe(0);\n\n  const testSnapshot = snapshot_UNSTABLE(({set}) => set(numberState, 1));\n  expect(testSnapshot.getLoadable(multipliedState).valueOrThrow()).toBe(100);\n});\n")),(0,s.kt)("h3",{id:"testing-async-selectors"},"Testing async selectors"),(0,s.kt)("p",null,"When testing an ",(0,s.kt)("strong",{parentName:"p"},"async selector"),", it is necessary to ",(0,s.kt)("inlineCode",{parentName:"p"},"retain()")," the snapshot to avoid early cancelation of the selector."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const initialSnapshot = snapshot_UNSTABLE();\nconst release = initialSnapshot.retain();\n\n// your test\n\nrelease();\n")),(0,s.kt)("h3",{id:"clearing-all-selector-caches"},"Clearing all selector caches"),(0,s.kt)("p",null,"Cache is shared between tests, so you'll need to clear the cache after each test."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},"const clearSelectorCachesState = selector({\n  key: 'ClearSelectorCaches',\n  get: ({getCallback}) => getCallback(({snapshot, refresh}) => () => {\n    for (const node of snapshot.getNodes_UNSTABLE()) {\n      refresh(node);\n    }\n  }),\n});\n\nconst clearSelectorCaches = testingSnapshot.getLoadable(clearSelectorCachesState).getValue();\n\n// Assuming we're in a file added to Jest's setupFilesAfterEnv:\nafterEach(clearSelectorCaches);\n")))}d.isMDXComponent=!0}}]);