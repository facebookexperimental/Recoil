"use strict";(self.webpackChunkrecoil=self.webpackChunkrecoil||[]).push([[7089],{8311:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"/2022/06/21/recoil-sync-0.1.0-release","metadata":{"permalink":"/zh-hans/blog/2022/06/21/recoil-sync-0.1.0-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2022-06-21-recoil-sync-0.1.0-release.md","source":"@site/blog/2022-06-21-recoil-sync-0.1.0-release.md","title":"Recoil Sync 0.1.0","description":"Initial open source release for the recoil-sync NPM package!  Recoil Sync provides an add-on library to help synchronize Recoil state with external systems.  Simple asynchronous data queries can be implemented via selectors or useEffect(), or atom effects can be used for bi-directional syncing of individual atoms.  The recoil-sync add-on package provides some additional functionality:","date":"2022-06-21T00:00:00.000Z","formattedDate":"2022\u5e746\u670821\u65e5","tags":[],"readingTime":2.405,"truncated":false,"authors":[],"nextItem":{"title":"Refine 0.1.0","permalink":"/zh-hans/blog/2022/06/21/refine-0.1.0-release"}},"content":"Initial open source release for the [`recoil-sync`](https://www.npmjs.com/package/recoil-sync) NPM package!  Recoil Sync provides an add-on library to help synchronize Recoil state with external systems.  Simple [asynchronous data queries](/docs/guides/asynchronous-data-queries) can be implemented via selectors or `useEffect()`, or [atom effects](/docs/guides/atom-effects) can be used for bi-directional syncing of individual atoms.  The `recoil-sync` add-on package provides some additional functionality:\\n\\n* **Batching Atomic Transactions** - Updates for multiple atoms can be batched together as a single transaction with the external system.  This can be important if an atomic transaction is required for consistent state of related atoms.\\n* **Abstract and Flexible** - This API allows users to specify what atoms to sync separately from describing the mechanism of how to sync.  This allows components to use atoms and sync with different systems in different environments without changing their implementation.  For example, a component may use atoms that persist to the URL when used in a stand-alone tool while persisting to a custom user database when embedded in another tool.\\n* **Validation and Backward Compatibility** - When dealing with state from external sources it is important to validate the input.  When state is persisted beyond the lifetime of an app it can also be important to consider backward compatibility of previous versions of state.  `recoil-sync` and [`refine`](/docs/refine/introduction) help provide this functionality.\\n* **Complex Mapping of Atoms to External Storage** - There may not be a one-to-one mapping between atoms and external storage items.  Atoms may migrate to use newer versions of items, may pull props from multiple items, just a piece of some compound state, or other complex mappings.\\n* **Sync with React Hooks or Props** - This library enables syncing atoms with React hooks or props that are not accessible from atom effects.\\n\\nThe `recoil-sync` library also provides built-in implementations for external stores, such as [syncing with the browser URL](/docs/recoil-sync/url-persistence).\\n\\n---\\n\\nThe basic idea is that a [`syncEffect()`](/docs/recoil-sync/sync-effect) can be added to each atom that you wish to sync, and then a [`<RecoilSync>`](/docs/recoil-sync/api/RecoilSync) is added inside your `<RecoilRoot>` to specify how to sync those atoms.  You can use built-in stores such as [`<RecoilURLSyncJSON>`](/docs/recoil-sync/url-persistence), [make your own](/docs/recoil-sync/implement-store), or even sync different groups of atoms with different stores.\\n\\n## Example\\n\\n### URL Persistence\\n\\nHere is a simple example [syncing an atom with the browser URL](/docs/recoil-sync/url-persistence):\\n\\n```jsx\\nconst currentUserState = atom<number>({\\n  key: \'CurrentUser\',\\n  default: 0,\\n  effects: [\\n    syncEffect({ refine: number() }),\\n  ],\\n});\\n```\\n\\nThen, at the root of your application, simply include [`<RecoilURLSyncJSON>`](/docs/recoil-sync/api/RecoilURLSyncJSON) to sync all of those tagged atoms with the URL\\n\\n```jsx\\nfunction MyApp() {\\n  return (\\n    <RecoilRoot>\\n      <RecoilURLSyncJSON location={{part: \'queryParams\'}}>\\n        ...\\n      </RecoilURLSyncJSON>\\n    </RecoilRoot>\\n  )\\n}\\n```\\n\\nThat\'s it!  Now this atom will initialize its state based on the URL during initial load, any state mutations will update the URL, and changes in the URL (such as the back button) will update the atom.  See more examples in the [Sync Effect](/docs/recoil-sync/sync-effect), [Store Implementation](/docs/recoil-sync/implement-store), and [URL Persistence](/docs/recoil-sync/url-persistence) guides."},{"id":"/2022/06/21/refine-0.1.0-release","metadata":{"permalink":"/zh-hans/blog/2022/06/21/refine-0.1.0-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2022-06-21-refine-0.1.0-release.md","source":"@site/blog/2022-06-21-refine-0.1.0-release.md","title":"Refine 0.1.0","description":"Initial open source release for the @recoiljs/refine library for type refinement and input validation for Flow and TypeScript!  To get started learning about Refine, check out the documentation on the core concepts of Utilities and Checkers.","date":"2022-06-21T00:00:00.000Z","formattedDate":"2022\u5e746\u670821\u65e5","tags":[],"readingTime":1.525,"truncated":false,"authors":[],"prevItem":{"title":"Recoil Sync 0.1.0","permalink":"/zh-hans/blog/2022/06/21/recoil-sync-0.1.0-release"},"nextItem":{"title":"Recoil 0.7.4","permalink":"/zh-hans/blog/2022/06/20/recoil-0.7.4-release"}},"content":"Initial open source release for the [`@recoiljs/refine`](https://www.npmjs.com/package/@recoiljs/refine) library for type refinement and input validation for Flow and TypeScript!  To get started learning about Refine, check out the documentation on the core concepts of [Utilities](/docs/refine/api/Utilities) and [Checkers](/docs/refine/api/Checkers).\\n\\nThe [Recoil Sync](/docs/recoil-sync/introduction) library leverages **Refine** for type refinement, input validation, and upgrading types for backward compatibility.  See the [`recoil-sync` docs](/docs/recoil-sync/introduction) for more details.\\n\\n### Why would I want to use Refine?\\n- Refine is useful when your code encounters `unknown` TypeScript type or `mixed` Flow type values and you need to [assert those values have a specific static type](/docs/refine/Introduction#type-refinement-example).\\n- Refine provides an API for building type-refinement helper functions which can validate that an unknown value conforms to an expected type.\\n- Refine can validate input values and [upgrade from previous versions](/docs/refine/Introduction#backward-compatible-example).\\n\\n### Type Refinement Example\\n\\nCoerce unknown types to a strongly typed variable.  [`assertion()`](/docs/refine/api/Utilities#assertion) will throw if the input doesn\'t match the expected type while [`coercion()`](/docs/refine/api/Utilities#coercion) will return `null`.\\n\\n```jsx\\nconst myObjectChecker = object({\\n  numberProperty: number(),\\n  stringProperty: optional(string()),\\n  arrayProperty: array(number()),\\n});\\n\\nconst myObjectAssertion = assertion(myObjectChecker);\\nconst myObject: CheckerReturnType<myObjectChecker> = myObjectAssertion({\\n  numberProperty: 123,\\n  stringProperty: \'hello\',\\n  arrayProperty: [1, 2, 3],\\n});\\n```\\n\\n### Backward Compatible Example\\n\\nUsing [`match()`](/docs/refine/api/Advanced_Checkers#match) and [`asType()`](/docs/refine/api/Advanced_Checkers#asType) you can upgrade from previous types to the latest version.\\n\\n```jsx\\nconst myChecker: Checker<{str: string}> = match(\\n  object({str: string()}),\\n  asType(string(), str => ({str: str})),\\n  asType(number(), num => ({str: String(num)})),\\n);\\n\\nconst obj1: {str: string} = coercion(myChecker({str: \'hello\'}));\\nconst obj2: {str: string} = coercion(myChecker(\'hello\'));\\nconst obj3: {str: string} = coercion(myChecker(123));\\n```\\n\\n\\n### JSON Parser Example\\n\\nRefine wraps `JSON` to provide a built-in strongly typed parser.\\n\\n```jsx\\nconst myParser = jsonParser(\\n    array(object({num: number()}))\\n);\\n\\nconst result = myParser(\'[{\\"num\\": 1}, {\\"num\\": 2}]\');\\n\\nif (result != null) {\\n  // we can now access values in num typesafe way\\n  assert(result[0].num === 1);\\n} else {\\n  // value failed to match parser spec\\n}\\n```"},{"id":"/2022/06/20/recoil-0.7.4-release","metadata":{"permalink":"/zh-hans/blog/2022/06/20/recoil-0.7.4-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2022-06-20-recoil-0.7.4-release.md","source":"@site/blog/2022-06-20-recoil-0.7.4-release.md","title":"Recoil 0.7.4","description":"- Fix missing flow types (#1857)","date":"2022-06-20T00:00:00.000Z","formattedDate":"2022\u5e746\u670820\u65e5","tags":[],"readingTime":0.095,"truncated":false,"authors":[],"prevItem":{"title":"Refine 0.1.0","permalink":"/zh-hans/blog/2022/06/21/refine-0.1.0-release"},"nextItem":{"title":"Recoil Relay 0.1.0","permalink":"/zh-hans/blog/2022/06/02/recoil-relay-0.1.0-release"}},"content":"- Fix missing flow types ([#1857](https://github.com/facebookexperimental/Recoil/pull/1857))\\n- Cleanup memory leak when using atoms with selector defaults. ([#1821](https://github.com/facebookexperimental/Recoil/pull/1821), [#1840](https://github.com/facebookexperimental/Recoil/pull/1840), [#1844](https://github.com/facebookexperimental/Recoil/pull/1844))"},{"id":"/2022/06/02/recoil-relay-0.1.0-release","metadata":{"permalink":"/zh-hans/blog/2022/06/02/recoil-relay-0.1.0-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2022-06-02-recoil-relay-0.1.0-release.md","source":"@site/blog/2022-06-02-recoil-relay-0.1.0-release.md","title":"Recoil Relay 0.1.0","description":"Initial open source release for the recoil-relay library for using GraphQL!","date":"2022-06-02T00:00:00.000Z","formattedDate":"2022\u5e746\u67082\u65e5","tags":[],"readingTime":0.72,"truncated":false,"authors":[],"prevItem":{"title":"Recoil 0.7.4","permalink":"/zh-hans/blog/2022/06/20/recoil-0.7.4-release"},"nextItem":{"title":"Recoil 0.7.3","permalink":"/zh-hans/blog/2022/06/01/recoil-0.7.3-release"}},"content":"Initial open source release for the [`recoil-relay`](/docs/recoil-relay/introduction) library for using **GraphQL**!\\n\\nThis library helps Recoil perform type safe and efficient queries using [GraphQL](https://graphql.org/) with the [Relay](https://relay.dev) library.  It provides selectors which can easily query with GraphQL.  The queries are synced with the Recoil data-flow graph so downstream selectors can derive state from them, they can depend on upstream Recoil state, and they are automatically subscribed to any changes in the graph from Relay.  Everything stays in sync automatically.\\n\\n### Example\\nA GraphQL query is as simple as defining a [GraphQL selector](/docs/recoil-relay/graphql-queries):\\n\\n```jsx\\nconst userNameQuery = graphQLSelector({\\n  key: \'UserName\',\\n  environment: myEnvironment,\\n  query: graphql`\\n    query UserQuery($id: ID!) {\\n      user(id: $id) {\\n        name\\n      }\\n    }\\n  `,\\n  variables: ({get}) => ({id: get(currentIDAtom)}),\\n  mapResponse: data => data.user?.name,\\n});\\n```\\nThen use it like any other Recoil [selector](/docs/introduction/core-concepts#selectors):\\n```jsx\\nfunction MyComponent() {\\n  const userName = useRecoilValue(userNameQuery);\\n  return <span>{userName}</span>;\\n}\\n```"},{"id":"/2022/06/01/recoil-0.7.3-release","metadata":{"permalink":"/zh-hans/blog/2022/06/01/recoil-0.7.3-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2022-06-01-recoil-0.7.3-release.md","source":"@site/blog/2022-06-01-recoil-0.7.3-release.md","title":"Recoil 0.7.3","description":"- Enable atoms and selectors to be used in family parameters (#1740)","date":"2022-06-01T00:00:00.000Z","formattedDate":"2022\u5e746\u67081\u65e5","tags":[],"readingTime":0.245,"truncated":false,"authors":[],"prevItem":{"title":"Recoil Relay 0.1.0","permalink":"/zh-hans/blog/2022/06/02/recoil-relay-0.1.0-release"},"nextItem":{"title":"Recoil 0.7.2","permalink":"/zh-hans/blog/2022/04/14/0.7.2-release"}},"content":"- Enable atoms and selectors to be used in [family parameters](/docs/api-reference/utils/selectorFamily#parameter-type) ([#1740](https://github.com/facebookexperimental/Recoil/pull/1740))\\n- Add `parentStoreID_UNSTABLE` to atom effects for the parent Recoil store the atom instance was cloned from.  This enables the [pre-fetch pattern for GraphQL](/docs/recoil-relay/graphql-queries#pre-fetch-graphql).  ([#1744](https://github.com/facebookexperimental/Recoil/pull/1744))\\n- Atom effects can initialize or set atoms to wrapped values ([#1681](https://github.com/facebookexperimental/Recoil/pull/1681))"},{"id":"/2022/04/14/0.7.2-release","metadata":{"permalink":"/zh-hans/blog/2022/04/14/0.7.2-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2022-04-14-0.7.2-release.md","source":"@site/blog/2022-04-14-0.7.2-release.md","title":"Recoil 0.7.2","description":"Selector optimizations and fixes","date":"2022-04-14T00:00:00.000Z","formattedDate":"2022\u5e744\u670814\u65e5","tags":[],"readingTime":0.155,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.7.3","permalink":"/zh-hans/blog/2022/06/01/recoil-0.7.3-release"},"nextItem":{"title":"Recoil 0.7.1","permalink":"/zh-hans/blog/2022/04/12/0.7.1-release"}},"content":"Selector optimizations and fixes\\n\\n\x3c!--truncate--\x3e\\n\\n### Optimizations and Fixes\\n- Selector cache lookup optimizations ([#1720](https://github.com/facebookexperimental/Recoil/pull/1720), [#1736](https://github.com/facebookexperimental/Recoil/pull/1736))\\n- Allow async selectors to re-evaluate when async dependencies are discovered with stale state ([#1736](https://github.com/facebookexperimental/Recoil/pull/1736))"},{"id":"/2022/04/12/0.7.1-release","metadata":{"permalink":"/zh-hans/blog/2022/04/12/0.7.1-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2022-04-12-0.7.1-release.md","source":"@site/blog/2022-04-12-0.7.1-release.md","title":"Recoil 0.7.1","description":"Typing and various improvements","date":"2022-04-12T00:00:00.000Z","formattedDate":"2022\u5e744\u670812\u65e5","tags":[],"readingTime":0.52,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.7.2","permalink":"/zh-hans/blog/2022/04/14/0.7.2-release"},"nextItem":{"title":"Recoil 0.7","permalink":"/zh-hans/blog/2022/03/25/0.7.0-release"}},"content":"Typing and various improvements\\n\\n\x3c!--truncate--\x3e\\n\\n### Typing\\n- Add explicit and required `children` prop to `<RecoilRoot>` and `useRecoilBridgeAcrossReactRoots_UNSTABLE()` for TypeScript to support the [removal of implicit children](https://solverfox.dev/writing/no-implicit-children/) with [`@types/react@^18.0.0](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/56210) for React 18. ([#1718](https://github.com/facebookexperimental/Recoil/pull/1718), [#1717](https://github.com/facebookexperimental/Recoil/pull/1717), [#1726](https://github.com/facebookexperimental/Recoil/pull/1726), [#1731](https://github.com/facebookexperimental/Recoil/pull/1731))\\n- Update typing for [family parameters](/docs/api-reference/utils/atomFamily#parameter-type) to better support Map, Set, and classes with `toJSON()`. ([#1709](https://github.com/facebookexperimental/Recoil/pull/1709), [#1703](https://github.com/facebookexperimental/Recoil/pull/1703))\\n\\n### Fixes\\n- Avoid dev-mode console error with React 18 when using shared async selectors across multiple `<RecoilRoot>`\'s. ([#1712](https://github.com/facebookexperimental/Recoil/pull/1712))\\n- Cleanup potential memory leak when using async selectors. ([#1714](https://github.com/facebookexperimental/Recoil/pull/1714))\\n- Fix potentially hung async selectors when shared across multiple roots that depend on atoms initialized with promises that don\'t resolve. ([#1714](https://github.com/facebookexperimental/Recoil/pull/1714))"},{"id":"/2022/03/25/0.7.0-release","metadata":{"permalink":"/zh-hans/blog/2022/03/25/0.7.0-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2022-03-25-0.7.0-release.md","source":"@site/blog/2022-03-25-0.7.0-release.md","title":"Recoil 0.7","description":"Recoil 0.7 offers some minor API improvements, selector optimizations, and other fixes.","date":"2022-03-25T00:00:00.000Z","formattedDate":"2022\u5e743\u670825\u65e5","tags":[],"readingTime":2.565,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.7.1","permalink":"/zh-hans/blog/2022/04/12/0.7.1-release"},"nextItem":{"title":"Recoil 0.6","permalink":"/zh-hans/blog/2022/01/28/0.6.0-release"}},"content":"Recoil 0.7 offers some minor API improvements, selector optimizations, and other fixes.\\n\\n\x3c!--truncate--\x3e\\n\\n## New Features\\n\\n### Atom Defaults are Optional\\nIt is now optional to provide a default value for an atom.  If no default is provided the atom will be kept in a \\"pending\\" state (e.g. triggering React Suspense) until it is set. ([#1639](https://github.com/facebookexperimental/Recoil/pull/1639))\\n\\nThis can help avoid awkward typing (such as unecessarily making the type nullable) or awkward placeholder values for the default.  An example minimal string atom might be:\\n```jsx\\natom<string>({key: \'MyString\'});\\n```\\nThis is also useful when atoms are initialized with atom effects and a default may not be necessary:\\n```jsx\\natom({\\n  key: \'MyQuery\',\\n  effects: [\\n    dbSyncEffect({query, variables}),\\n  ],\\n});\\n```\\n\\n### Other New Features\\n- Add `.getStoreID()` method to [`Snapshot`](/docs/api-reference/core/Snapshot) ([#1612](https://github.com/facebookexperimental/Recoil/pull/1612))\\n- Publish `RecoilLoadable.loading()` factory for making an async [`Loadable`](/docs/api-reference/core/Loadable) which never resolves. ([#1641](https://github.com/facebookexperimental/Recoil/pull/1641))\\n\\n## Improvements / Optimizations\\n### Automatically retain snapshots for the duration of async callbacks.\\nYou now no longer need to manually retain snapshots for async callbacks from [`useRecoilCallback()`](/docs/api-reference/core/useRecoilCallback).  ([#1632](https://github.com/facebookexperimental/Recoil/pull/1632))\\n```jsx\\n  const myCallback = useRecoilCallback(({snapshot}) => async () => {\\n    // No longer necessary to retain() here\\n    await something;\\n    ... use snapshot ...\\n  });\\n```\\nIf you want to save a Snapshot or reference it from closure state from some other scheduled handler, then you still need to [manually retain it](/docs/api-reference/core/Snapshot#asynchronous-use-of-snapshots).\\n\\n### Other Improvements / Optimizations\\n- Optimizations for scaling with more selector dependencies.  2x improvement with 100 dependencies, 4x with 1,000, and now able to support 10,000+ dependencies. ([#1651](https://github.com/facebookexperimental/Recoil/pull/1651), [#1515](https://github.com/facebookexperimental/Recoil/pull/1515), [#914](https://github.com/facebookexperimental/Recoil/pull/914))\\n- Better error reporting when user selector implementations provide inconsistent results ([#1696](https://github.com/facebookexperimental/Recoil/pull/1696))\\n\\n## Breaking Changes\\n### Selector evaluation or atom defaults can use a Loadable object\\n\\nNow the selector `get()` evaluation callback or atom `default` property can use a [`Loadable`](/docs/api-reference/core/Loadable) object. ([#1640](https://github.com/facebookexperimental/Recoil/pull/1640)) This can allow them to more cleanly accept synchronous error states:\\n```jsx\\natom({\\n  key: \'Key\',\\n  default: RecoilLoadable.error(new Error(\'ERROR\')),\\n});\\n```\\nor mapped Loadables or placeholders:\\n```jsx\\nselector({\\n  key: \'Key\',\\n  get: ({get}) => {\\n    const queryLoadable = get(noWait(myQuerySelector));\\n    if (queryLoadable.state === \'loading\') {\\n      return PLACEHOLDER;\\n    }\\n    return queryLoadable; // Pass on the query results or error state.\\n  }\\n})\\n```\\n\\nIf you wish to explicitly evaluate a selector value to a `Promise`, `Loadable`, or `RecoilState` type object then you can now wrap them with `selector.value()` or `atom.value()`.\\n```jsx\\nselector({\\n  key: \'Key\',\\n  get: ({get}) => {\\n    // Returns an immediate synchronous value\\n    return selector.value(Promise.resolve(\'Promise as a value\'));\\n  },\\n});\\n```\\n\\nThis is only a minor change.  It helps make the API more consisent for handling wrappers such as `Promise` and `Loadable`, though is not yet available across the entire API.  But, it helps set the stage for future potential ability to explicitly set atoms and selectors to asynchronous values or error states.\\n\\n### Other Breaking Changes\\n- [`useRecoilCallback()`](/docs/api-reference/core/useRecoilCallback) now provides a snapshot for the latest state instead of the latest rendered state, which had bugs ([#1610](https://github.com/facebookexperimental/Recoil/pull/1610), [#1604](https://github.com/facebookexperimental/Recoil/pull/1604))\\n\\n## Fixes\\n- Freezing user values in dev mode now works in JS environments without the `Window` interface. ([#1571](https://github.com/facebookexperimental/Recoil/pull/1571))\\n- Avoid spurious console errors from atom effects when calling `setSelf()` from `onSet()` handlers. ([#1589](https://github.com/facebookexperimental/Recoil/pull/1589), [#1582](https://github.com/facebookexperimental/Recoil/pull/1582))"},{"id":"/2022/01/28/0.6.0-release","metadata":{"permalink":"/zh-hans/blog/2022/01/28/0.6.0-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2022-01-28-0.6.0-release.md","source":"@site/blog/2022-01-28-0.6.0-release.md","title":"Recoil 0.6","description":"Recoil 0.6 introduces improved support for React 18, including concurrent rendering and transitions, along with new APIs, fixes, and optimizations.","date":"2022-01-28T00:00:00.000Z","formattedDate":"2022\u5e741\u670828\u65e5","tags":[],"readingTime":3.36,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.7","permalink":"/zh-hans/blog/2022/03/25/0.7.0-release"},"nextItem":{"title":"Recoil 0.5","permalink":"/zh-hans/blog/2021/11/03/0.5.0-release"}},"content":"Recoil 0.6 introduces improved support for React 18, including concurrent rendering and transitions, along with new APIs, fixes, and optimizations.\\n\\n\x3c!--truncate--\x3e\\n\\n## React 18\\n\\nRecoil 0.6 uses the latest APIs from React 18 for improved safety and performance.  This release is compatible with [concurrent rendering](https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html#whats-coming-in-react-18) and [`<React.StrictMode>`](https://reactjs.org/docs/strict-mode.html), which is useful for testing and identifying potential issues for concurrent rendering.  Making Recoil and React state changes in the same batch now stay in sync to provided a consistent view of state.  Some of these improvements are also available while using previous versions of React.  *When experimenting with React 18 please use the latest RC build, as the original React `18.0.0-rc.0` package has a bug that has since been fixed.*\\n\\n### Concurrent Rendering and Transitions\\n\\nReact 18 offers a new hook [`useTransition()`](https://reactjs.org/docs/concurrent-mode-patterns.html#transitions) for transitioning to a new state while having control over what to render before the new state is ready.  Recoil should be compatible with this approach and provides a consistent view with React state.  However, React 18 may fallback from concurrent updates and does not yet officially support initiating transitions based on state changes to external stores.  This is something the React team is looking into supporting, but until then we have added experimental support for this through the following hooks.  This API is considered experimental because there may be use cases we haven\u2019t found which are not handled.\\n* `useRecoilState_TRANSITION_SUPPORT_UNSTABLE()`\\n* `useRecoilValue_TRANSITION_SUPPORT_UNSTABLE()`\\n* `useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE()`\\n\\nHere\'s an example that displays the current results while a new result is loading:\\n```jsx\\nfunction QueryResults() {\\n  const queryParams = useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(queryParamsAtom);\\n  const results = useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(myQuerySelector(queryParams));\\n  return results;\\n}\\n\\nfunction MyApp() {\\n  const [queryParams, setQueryParams] = useRecoilState_TRANSITION_SUPPORT_UNSTABLE(queryParamsAtom);\\n  const [inTransition, startTransition] = useTransition();\\n  return (\\n    <div>\\n      {inTransition ? <div>[Loading new results...]</div> : \'\'}\\n      Results: <React.Suspense><QueryResults /></React.Suspense>\\n      <button\\n        onClick={() => {\\n          startTransition(() => {\\n            setQueryParams(...new params...);\\n          });\\n        }\\n      >\\n        Start New Query\\n      </button>\\n    </div>\\n  );\\n}\\n```\\n\\n## New Features\\n\\n* Recoil Callbacks\\n  * [`useRecoilCallback()`](/docs/api-reference/core/useRecoilCallback) can now also refresh selector caches, similar to [`useRecoilRefresher_UNSTABLE()`](/docs/api-reference/core/useRecoilRefresher). ([#1413](https://github.com/facebookexperimental/Recoil/pull/1413))\\n  * Callbacks from selectors using [`getCallback()`](/docs/api-reference/core/selector#returning-objects-with-callbacks) can now mutate, refresh, and transact state in addition to reading it, similar to [`useRecoilCallback()`](/docs/api-reference/core/useRecoilCallback). ([#1498](https://github.com/facebookexperimental/Recoil/pull/1498))\\n* Store IDs - A `StoreID` can now be obtained using [`useRecoilStoreID()`](/docs/api-reference/core/useRecoilStoreID) ([#1417](https://github.com/facebookexperimental/Recoil/pull/1417)) or the `storeID` parameter in [atom effects](/docs/guides/atom-effects)  ([#1414](https://github.com/facebookexperimental/Recoil/pull/1414)).\\n* [`RecoilLoadable.of()`](/docs/api-reference/core/Loadable#examples) and [`RecoilLoadable.all()`](/docs/api-reference/core/Loadable#examples) factories now accept either literal values, async Promises, or Loadables.  This is comparable to `Promise.resolve()` and `Promise.all()`  ([#1455](https://github.com/facebookexperimental/Recoil/pull/1455), [#1442](https://github.com/facebookexperimental/Recoil/pull/1442)).\\n* Add `.isRetained()` method for Snapshots and check if snapshot is already released when using `.retain()` in development ([#1546](https://github.com/facebookexperimental/Recoil/pull/1546))\\n\\n## Breaking Changes\\n- Atom Effects\\n  - Rename option from `effects_UNSTABLE` to just `effects`, as the interface is mostly stabilizing. ([#1520](https://github.com/facebookexperimental/Recoil/pull/1520))\\n  - [Atom effect](/docs/guides/atom-effects) initializations takes precedence over `<RecoilRoot initializeState={...}>`. ([#1509](https://github.com/facebookexperimental/Recoil/pull/1509))\\n- `useGetRecoilValueInfo_UNSTABLE()` and `Snapshot#getInfo_UNSTABLE()` always report the node `type`. ([#1547](https://github.com/facebookexperimental/Recoil/pull/1547))\\n- The [0.3](/blog/2021/05/14/0.3.0-released#breaking-change-preparing-for-memory-management) release introduced the need to retain Snapshots for later use, but it was mostly a warning.  Now it is necessary to retain a Snapshot for asynchronous selectors to resolve.  See the documentation [here](/docs/api-reference/core/Snapshot#asynchronous-use-of-snapshots) and [here](/docs/guides/testing#testing-async-selectors).  Future releases will further enforce this as garbage collection is released.\\n\\n## Other Fixes and Optimizations\\n- Reduce overhead of snapshot cloning\\n  - Only clone the current snapshot for callbacks if the callback actually uses it. ([#1501](https://github.com/facebookexperimental/Recoil/pull/1501))\\n  - Cache the cloned snapshots from callbacks unless there was a state change. ([#1533](https://github.com/facebookexperimental/Recoil/pull/1533))\\n- Fix transitive selector refresh for some cases ([#1409](https://github.com/facebookexperimental/Recoil/pull/1409))\\n- Fix some corner cases with async selectors and multiple stores ([#1568](https://github.com/facebookexperimental/Recoil/pull/1568))\\n- Atom effects\\n  - Run atom effects when atoms are initialized from a `set()` during a transaction from [`useRecoilTransaction_UNSTABLE()`](/docs/api-reference/core/useRecoilTransaction) ([#1466](https://github.com/facebookexperimental/Recoil/pull/1466), [#1569](https://github.com/facebookexperimental/Recoil/pull/1569))\\n  - Atom effects are cleaned up when initialized by a Snapshot which is released. ([#1511](https://github.com/facebookexperimental/Recoil/pull/1511), [#1532](https://github.com/facebookexperimental/Recoil/pull/1532))\\n  - Unsubscribe `onSet()` handlers in atom effects when atoms are cleaned up. ([#1509](https://github.com/facebookexperimental/Recoil/pull/1509))\\n  - Call `onSet()` when atoms are initialized with `<RecoilRoot initializeState={...} >` ([#1519](https://github.com/facebookexperimental/Recoil/pull/1519), [#1511](https://github.com/facebookexperimental/Recoil/pull/1511))\\n- Avoid extra re-renders in some cases when a component uses a different atom/selector. ([#825](https://github.com/facebookexperimental/Recoil/pull/825))\\n- `<RecoilRoot>` will only call `initializeState()` once during the initial render. ([#1372](https://github.com/facebookexperimental/Recoil/pull/1372))\\n- Lazily compute and memoize the results of lazy properties, such as from `useGetRecoilValueInfo()` or `Snapshot#getInfo_UNSTABLE()`. ([#1548](https://github.com/facebookexperimental/Recoil/pull/1548), [#1549](https://github.com/facebookexperimental/Recoil/pull/1549))"},{"id":"/2021/11/03/0.5.0-release","metadata":{"permalink":"/zh-hans/blog/2021/11/03/0.5.0-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2021-11-03-0.5.0-release.md","source":"@site/blog/2021-11-03-0.5.0-release.md","title":"Recoil 0.5","description":"Welcome to Recoil 0.5 with a few new APIs and improvements.","date":"2021-11-03T00:00:00.000Z","formattedDate":"2021\u5e7411\u67083\u65e5","tags":[],"readingTime":0.975,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.6","permalink":"/zh-hans/blog/2022/01/28/0.6.0-release"},"nextItem":{"title":"Recoil 0.4.1","permalink":"/zh-hans/blog/2021/08/26/0.4.1-release"}},"content":"Welcome to Recoil 0.5 with a few new APIs and improvements.\\n\\n\x3c!--truncate--\x3e\\n\\n## Hook for refreshing selectors\\n\\nThe [`useRecoilRefresher_UNSTABLE()`](/docs/api-reference/core/useRecoilRefresher) hook has been added for refreshing selectors that execute data queries.  This is useful if you just want to refresh for newer data or retry due to an error.  ([#972](https://github.com/facebookexperimental/Recoil/pull/972), [#1294](https://github.com/facebookexperimental/Recoil/pull/1294), [#1302](https://github.com/facebookexperimental/Recoil/pull/1302))\\n\\n## Atom effect improvements\\n\\n* Add `isReset` parameter to `onSet()` callback to know if the atom was reset.  ([#1358](https://github.com/facebookexperimental/Recoil/pull/1358), [#1345](https://github.com/facebookexperimental/Recoil/pull/1345))\\n* Add `getLoadable()`, `getPromise()`, and `getInfo_UNSTABLE()` for reading other atoms.  ([#1205](https://github.com/facebookexperimental/Recoil/pull/1205), [#1210](https://github.com/facebookexperimental/Recoil/pull/1210))\\n\\n## Loadable factories\\n\\nThe [`RecoilLoadable`](/docs/api-reference/core/Loadable#creating-loadables) interface is now available for making your own `Loadable` objects.  ([#1263](https://github.com/facebookexperimental/Recoil/pull/1263), [#1264](https://github.com/facebookexperimental/Recoil/pull/1264), [#1312](https://github.com/facebookexperimental/Recoil/pull/1312))\\n\\n## Other fixes and improvements\\n\\n- Allow class instances in family parameters for Flow ([#1215](https://github.com/facebookexperimental/Recoil/pull/1215))\\n- `Loadable` improvements:\\n  - Ability to map Loadables with other Loadables. ([#1180](https://github.com/facebookexperimental/Recoil/pull/1180))\\n  - Re-implement Loadable as classes. ([#1315](https://github.com/facebookexperimental/Recoil/pull/1315))\\n- Fix user-thrown promises in selectors for some cases.\\n- Improved dev-mode checks:\\n  - Atoms freeze default, initialized, and async values.  Selectors should not freeze upstream dependencies. ([#1261](https://github.com/facebookexperimental/Recoil/pull/1261), [#1259](https://github.com/facebookexperimental/Recoil/pull/1259))\\n  - Perform runtime check that required options are provided when creating atoms and selectors. ([#1324](https://github.com/facebookexperimental/Recoil/pull/1324))\\n- Upgrade Prettier version ([#1366](https://github.com/facebookexperimental/Recoil/pull/1366))\\n\\n*Also lots of restructuring in preparation for the upcoming `recoil-sync` library release...*"},{"id":"/2021/08/26/0.4.1-release","metadata":{"permalink":"/zh-hans/blog/2021/08/26/0.4.1-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2021-08-26-0.4.1-release.md","source":"@site/blog/2021-08-26-0.4.1-release.md","title":"Recoil 0.4.1","description":"Recoil 0.4.1 has been released with some performance optimizations and fixes focused on optimizing when React will re-render components based on Recoil state changes.","date":"2021-08-26T00:00:00.000Z","formattedDate":"2021\u5e748\u670826\u65e5","tags":[],"readingTime":0.475,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.5","permalink":"/zh-hans/blog/2021/11/03/0.5.0-release"},"nextItem":{"title":"Recoil 0.4","permalink":"/zh-hans/blog/2021/07/30/0.4.0-release"}},"content":"Recoil 0.4.1 has been released with some performance optimizations and fixes focused on optimizing when React will re-render components based on Recoil state changes.\\n\\n\x3c!--truncate--\x3e\\n\\n- Components using selectors will no longer re-render if the selector evaluates to an equivalent value, based on reference equality.\\n- Components previously rendered twice on initial render when not using React\'s Concurrent Mode.\\n- When selectors have async dependencies that resolve, some environments of React that previously caused unnecessary re-renders no longer will.\\n- Components did not always re-render properly when selectors changed async dependencies based on other dependencies."},{"id":"/2021/07/30/0.4.0-release","metadata":{"permalink":"/zh-hans/blog/2021/07/30/0.4.0-release","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2021-07-30-0.4.0-release.md","source":"@site/blog/2021-07-30-0.4.0-release.md","title":"Recoil 0.4","description":"We are pleased to announce the release of Recoil 0.4 with configurable selector caches, improved API for transactions with multiple atoms, and other optimizations and fixes.","date":"2021-07-30T00:00:00.000Z","formattedDate":"2021\u5e747\u670830\u65e5","tags":[],"readingTime":3.965,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.4.1","permalink":"/zh-hans/blog/2021/08/26/0.4.1-release"},"nextItem":{"title":"Recoil 0.3","permalink":"/zh-hans/blog/2021/05/14/0.3.0-released"}},"content":"We are pleased to announce the release of Recoil 0.4 with configurable selector caches, improved API for transactions with multiple atoms, and other optimizations and fixes.\\n\\n\x3c!--truncate--\x3e\\n\\n## Configurable selector caches\\n\\nThe new [`cachePolicy_UNSTABLE`](/docs/api-reference/core/selector#cache-policy-configuration) property in [selectors](/docs/api-reference/core/selector) and [selector families](/docs/api-reference/utils/selectorFamily) allows you to configure the caching behavior of a selector\'s internal cache.  This property can be useful for reducing memory in applications that have a large number of selectors or selectors that have a large number of changing dependencies.\\n\\nBelow is an example of how you might use this new property:\\n\\n```jsx\\nconst clockState = selector({\\n  key: \'clockState\',\\n  get: ({get}) => {\\n    const hour = get(hourState);\\n    const minute = get(minuteState);\\n    const second = get(secondState); // will re-run every second\\n\\n    return `${hour}:${minute}:${second}`;\\n  },\\n  cachePolicy_UNSTABLE: {\\n    // Only store the most recent set of dependencies and their values\\n    eviction: \'most-recent\',\\n  },\\n});\\n```\\n\\nIn the example above, `clockState` recalculates every second, adding a new set of dependency values to the internal cache, which may lead to a memory issue over time as the internal cache grows indefinitely. Using the `most-recent` eviction policy, the internal selector cache will only retain the most recent set of dependencies and their values, along with the actual selector value based on those dependencies, thus solving the memory issue.\\n\\nCurrent eviction options are:\\n- `lru` - evicts the least-recently-used value from the cache when the size exceeds `maxSize`.\\n- `most-recent` - retains only the most recent value.\\n- `keep-all` (default) - keeps all entries in the cache and does not evict.\\n\\n> **_NOTE:_** *The default eviction policy (currently `keep-all`) may change in the future.*\\n\\n## Transactions with multiple atoms\\n\\nIntroducing an improved API for updating multiple atoms together as a single transaction.  The new [`useRecoilTransaction_UNSTABLE()`](/docs/api-reference/core/useRecoilTransaction) hook is easier, more efficient, and safer than before.  This new hook should eventually replace most uses of [`useRecoilCallback()`](/docs/api-reference/core/useRecoilCallback), however this release is only an initial implementation with [certain limitations](/docs/api-reference/core/useRecoilTransaction#current-limitations-and-future-vision) that will be addressed in future releases.\\n\\n### Example\\n\\nSuppose we have two atoms, `positionState` and `headingState`, and we\'d like to update them together as part of a single action, where the new value of `positionState` is a function of *both* the current value of `positionState` and `headingState`.  You can accomplish this with a transaction, which must be a pure function without side-effects:\\n\\n```jsx\\nconst goForward = useRecoilTransaction_UNSTABLE(({get, set}) => (distance) => {\\n  const heading = get(headingState);\\n  const position = get(positionState);\\n  set(positionAtom, {\\n    x: position.x + cos(heading) * distance,\\n    y: position.y + sin(heading) * distance,\\n  });\\n});\\n```\\n\\nThen you can execute the transaction by just calling `goForward(distance)` in an event handler.  This will update state based on the *current* values, not the state when the components rendered.  You can also read the values of previous writes during a transaction.  Because no other updates will be committed while the updater is executing, you will see a consistent store of state.\\n\\nthe previous approach using [`useRecoilCallback()`](/docs/api-reference/core/useRecoilCallback) might have looked like the following:\\n\\n```jsx\\nconst goForward = useRecoilCallback(({snapshot, gotoSnapshot}) => (distance) => {\\n  const mutatedSnapshot = snapshot.map(({get, set}) => {\\n    const heading = get(headingState);\\n    const position = get(positionState);\\n    set(positionState, {\\n      x: position.x + cos(heading) * distance,\\n      y: position.y + sin(heading) * distance,\\n    });\\n  });\\n  gotoSnapshot(mutatedSnapshot);\\n});\\n```\\n\\nThis has the following drawbacks:\\n* There is performance overhead for managing the full generality of snapshots.\\n* There is more opportunity for bugs:  The snapshot might be retained and used in the future.  Since a snapshot contains the complete set of Recoil state, not just a changeset, that could accidentally rewind changes that occurred between creating and committing the snapshot.\\n\\n### Reducer Example\\n\\nYou can also use this hook to create a reducer pattern of executing actions over multiple atoms:\\n\\n```jsx\\nconst reducer = useRecoilTransaction_UNSTABLE(({get, set}) => action => {\\n  switch(action.type) {\\n    case \'goForward\':\\n      const heading = get(headingState);\\n      set(positionState, position => {\\n        x: position.x + cos(heading) * action.distance,\\n        y: position.y + sin(heading) * action.distance,\\n      });\\n      break;\\n\\n    case \'turn\':\\n      set(headingState, action.heading);\\n      break;\\n  }\\n});\\n```\\n\\n## Fixes and Optimizations\\n\\n- Fix TypeScript typing for `selectorFamily()`, `getCallback()`, `useGetRecoilValueInfo()`, and `Snapshot#getNodes()` ([#1060](https://github.com/facebookexperimental/Recoil/pull/1060), [#1116](https://github.com/facebookexperimental/Recoil/pull/1116), [#1123](https://github.com/facebookexperimental/Recoil/pull/1123))\\n- Allow mutable values in selectors (enabled via the `dangerouslyAllowMutability` selector option) to be used with `waitFor*()` helpers such as [`waitForAll()`](/docs/api-reference/utils/waitForAll) ([#1074](https://github.com/facebookexperimental/Recoil/pull/1074), [#1096](https://github.com/facebookexperimental/Recoil/pull/1096))\\n- [Atom Effects](/docs/guides/atom-effects) fixes:\\n  - Fix `onSet()` handler to get the proper new value when an atom is reset or has an async default Promise that resolves ([#1059](https://github.com/facebookexperimental/Recoil/pull/1059), [#1050](https://github.com/facebookexperimental/Recoil/pull/1050), [#738](https://github.com/facebookexperimental/Recoil/pull/738)) (This is a slightly breaking change because the actual new value will be provided to the handler instead of a `DefaultValue` placeholder)\\n  - Fix support for multiple Atom Effects cleanup handlers ([#1125](https://github.com/facebookexperimental/Recoil/pull/1125))\\n  - Fix selector subscriptions when atoms with effects are initialized via a `Snapshot` ([#1135](https://github.com/facebookexperimental/Recoil/pull/1135), [#1107](https://github.com/facebookexperimental/Recoil/pull/1107))\\n- Optimization for async selectors when dependencies resolve to cached values ([#1037](https://github.com/facebookexperimental/Recoil/pull/1037))\\n- Remove unnecessary warning message ([#1034](https://github.com/facebookexperimental/Recoil/pull/1034), [#1062](https://github.com/facebookexperimental/Recoil/pull/1062))"},{"id":"/2021/05/14/0.3.0-released","metadata":{"permalink":"/zh-hans/blog/2021/05/14/0.3.0-released","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2021-05-14-0.3.0-released.md","source":"@site/blog/2021-05-14-0.3.0-released.md","title":"Recoil 0.3","description":"We are pleased to announce the release of Recoil 0.3 with more flexible RecoilRoot nesting, callback generation, preparation for memory management, optimizations, and bug fixes.","date":"2021-05-14T00:00:00.000Z","formattedDate":"2021\u5e745\u670814\u65e5","tags":[],"readingTime":1.81,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.4","permalink":"/zh-hans/blog/2021/07/30/0.4.0-release"},"nextItem":{"title":"Recoil 0.2","permalink":"/zh-hans/blog/2021/03/22/0.2.0-released"}},"content":"We are pleased to announce the release of Recoil 0.3 with more flexible RecoilRoot nesting, callback generation, preparation for memory management, optimizations, and bug fixes.\\n\\n\x3c!--truncate--\x3e\\n\\n## New Features\\n\\n* You can now create a RecoilRoot that falls through to the surrounding root if one exists. This lets you create re-usable components that use Recoil, yet can be used within or without the context of a larger Recoil app. ([#973](https://github.com/facebookexperimental/Recoil/pull/973))\\n* You can now return Recoil callbacks from selectors. ([#989](https://github.com/facebookexperimental/Recoil/pull/989))\\n\\n## Breaking Change: Preparing for Memory Management\\n\\nThe next release of Recoil will have a breaking API change. Today\'s release issues a console warning in development builds if you have any code that will need to be updated. Most apps will not need any code changes.\\n\\nWhen we ship memory management, Snapshots (such as the one you get as an argument to `useRecoilCallback()`) will only be valid for the tick in which they are created. If you want to keep a Snapshot around for longer, you need to manually retain and then release it:\\n\\n```js\\nconst release = snapshot.retain();\\ntry {\\n  await someAsyncWork(snapshot);\\n} finally {\\n  release();\\n}\\n```\\n\\nIn 0.3.0, if you use a Snapshot that hasn\'t been retained, you will get a console warning in development. There is no change in behavior in production. In the next release, it will throw an exception, in both development and production.\\n\\nRetaining Snapshots should be avoided whenever possible, because it will prevent reclaiming of memory for all atoms for as long as that Snapshot is retained. Instead, pull out just the values you need before going to async.\\n\\n## Bug Fixes, Performance, and Other Improvements\\n\\n* Reduced overhead when using `atomFamily`. One app with thousands of atoms saw 200MB less memory usage.\\n* Fix a bug where errors throws from async selectors were not caught by React error boundaries. ([#998](https://github.com/facebookexperimental/Recoil/pull/998), [#1017](https://github.com/facebookexperimental/Recoil/pull/1017))\\n* Experimental Atom Effects `onSet()` is no longer called when triggered from `setSelf()` initializing with a Promise or from the same `onSet()` handler.  ([#974](https://github.com/facebookexperimental/Recoil/pull/974), [#979](https://github.com/facebookexperimental/Recoil/pull/979), [#953](https://github.com/facebookexperimental/Recoil/pull/953), [#986](https://github.com/facebookexperimental/Recoil/pull/986))\\n* Improved support for Safari. ([#967](https://github.com/facebookexperimental/Recoil/pull/967), [#609](https://github.com/facebookexperimental/Recoil/pull/609))\\n* Values stored in selectors are now frozen in dev mode. ([#911](https://github.com/facebookexperimental/Recoil/pull/911))\\n* Improved TypeScript support for `Loadable`s."},{"id":"/2021/03/22/0.2.0-released","metadata":{"permalink":"/zh-hans/blog/2021/03/22/0.2.0-released","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2021-03-22-0.2.0-released.md","source":"@site/blog/2021-03-22-0.2.0-released.md","title":"Recoil 0.2","description":"We are pleased to announce the release of Recoil 0.2.0. This release has a new, more reliable implementation of async selectors, greatly improved performance, and many bug fixes and improvements.","date":"2021-03-22T00:00:00.000Z","formattedDate":"2021\u5e743\u670822\u65e5","tags":[],"readingTime":3.005,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.3","permalink":"/zh-hans/blog/2021/05/14/0.3.0-released"},"nextItem":{"title":"Recoil 0.1.1","permalink":"/zh-hans/blog/2020/10/30/0.1.1-released"}},"content":"We are pleased to announce the release of Recoil 0.2.0. This release has a new, more reliable implementation of async selectors, greatly improved performance, and many bug fixes and improvements.\\n\\n\x3c!--truncate--\x3e\\n\\n## Better Async Selectors\\n\\nWe\'ve reimplemented selectors to fix a number of corner cases that we didn\'t handle before. For instance:\\n\\n* Selectors can now add dependencies at any point in their async execution.\\n* Selectors now start over if their dependencies change while they\'re awaiting something.\\n* Diamond dependency patterns now re-execute only the necessary selectors.\\n\\nThese are just a few of the unit tests that pass only with the new implementation. You are now less likely to hit incorrect behavior when using async selectors in Recoil.\\n\\nMany of the fixed bugs manifested as unnecessary execution of selectors. In one app that heavily uses async selectors, we observed an overall 15% decrease in the number of selector executions.\\n\\nChristian Santos ([@csantos42](https://github.com/csantos42)) has been working on this with great diligence and we\'re extremely happy to release it today.\\n\\n## Scaling to Large Numbers of Atoms\\n\\nRecoil now uses [special data structures](https://en.wikipedia.org/wiki/Hash_array_mapped_trie) to maintain efficiency with large numbers of atoms. It is now hundreds of times faster when using 10,000 atoms.\\n\\n## Logo\\n\\nRecoil now has a logo. Thanks to Gray Pegg ([@graypegg](https://github.com/graypegg)) for designing it and for sprucing up our website!\\n\\n## Other Improvements\\n\\n- Error handling with `waitForAny()` has changed: It now lets you access the individual `Loadable`s corresponding to its arguments, even if one of them is in an error state. This makes it more consistent with `waitForNone()`.\\n- Added a `waitForAllSettled()` helper analogous to `Promise.allSettled`.\\n- Friendlier error message for misuse of `useRecoilCallback()`. ([#870](https://github.com/facebookexperimental/Recoil/pull/870))\\n- Friendlier error message if you try to use an async function as a selector setter, which is not supported. ([#777](https://github.com/facebookexperimental/Recoil/pull/777))\\n- Improved React Native support. ([#748](https://github.com/facebookexperimental/Recoil/pull/748), [#702](https://github.com/facebookexperimental/Recoil/pull/702))\\n- Added a `useGetRecoilValueInfo_UNSTABLE()` hook for use by dev tools. ([#713](https://github.com/facebookexperimental/Recoil/pull/713), [#714](https://github.com/facebookexperimental/Recoil/pull/714))\\n\\n## Bug Fixes\\n\\n- Selectors now treat any non-`Promise` that is thrown as an error, rather than only instances of `Error`.\\n- `<RecoilRoot>` could sometimes have its state updated after being unmounted. ([#917](https://github.com/facebookexperimental/Recoil/pull/917))\\n- The error message for a missing `<RecoilRoot>` wasn\'t displayed on React experimental releases. ([#712](https://github.com/facebookexperimental/Recoil/pull/712))\\n- Errors are no longer frozen. ([#852](https://github.com/facebookexperimental/Recoil/pull/852))\\n- Atom effects could fail to initialize atoms in certain cases ([#775](https://github.com/facebookexperimental/Recoil/pull/775)).\\n- Async selectors would fail with multiple React roots.\\n- IE 11 compatibility ([#894](https://github.com/facebookexperimental/Recoil/pull/894) and more)\\n\\n## Breaking Changes\\n\\nAs mentioned above, the behavior of `waitForAny()` has changed. If you rely on the behavior that `waitForAny()` resulted in an error state if any of its arguments is in an error state, your code will break. Now it returns individual `Loadable`s for each argument, just as with the non-error state, and you can check for an error in each argument.\\n\\nIf you throw something that is not a `Promise` and not an `Error` from within a selector, it will now put the selector into an error state instead of treating the thrown object as a value.\\n\\n## Future Work\\n\\nWe are very close to releasing Memory Management, which will allow Recoil to automatically delete atoms and selectors that are no longer being used, configurable on a per-atom basis. This will also include configurable LRU caching for selectors.\\nThese new features are in use internally at Facebook, but require a slight breaking change to the API. So our next release will start warning in cases where your code will break. The required changes are not difficult, and should be rare: Out of thousands of modules that import Recoil, we found less than half a dozen that required changes."},{"id":"/2020/10/30/0.1.1-released","metadata":{"permalink":"/zh-hans/blog/2020/10/30/0.1.1-released","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2020-10-30-0.1.1-released.md","source":"@site/blog/2020-10-30-0.1.1-released.md","title":"Recoil 0.1.1","description":"Welcome to Recoil version 0.1.1!  This release has performance improvements and introduces several experimental features such as support for React Native, working with Snapshots outside of React, and atom effects for managing side-effects of atoms such as logging, synchronization with external stores, persistence, etc.","date":"2020-10-30T00:00:00.000Z","formattedDate":"2020\u5e7410\u670830\u65e5","tags":[],"readingTime":2.145,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.2","permalink":"/zh-hans/blog/2021/03/22/0.2.0-released"},"nextItem":{"title":"Recoil 0.0.11","permalink":"/zh-hans/blog/2020/09/15/0.0.11-released"}},"content":"Welcome to Recoil version 0.1.1!  This release has performance improvements and introduces several *experimental* features such as support for React Native, working with Snapshots outside of React, and atom effects for managing side-effects of atoms such as logging, synchronization with external stores, persistence, etc.\\n\\n\x3c!--truncate--\x3e\\n\\nAlso, [nightly builds](/docs/introduction/installation#nightly-builds) are now available via the `nightly` branch.\\n\\n## Performance\\n\\nSeveral changes to improve Recoil\'s performance:\\n* Updates performed during `useRecoilCallback()` are now batched, which avoids copying data structures or performing updates for intermediate states.  This allowed setting 5,000 atoms in a loop to go from 10s -> 25ms with some of our stress tests. ([@davidmccabe](https://github.com/davidmccabe))\\n* Recoil also now avoids looking up selector values in cache if the selector\'s dependencies have not changed.  This improved some applications with complex data-flow graphs by 30-40x. ([@davidmccabe](https://github.com/davidmccabe))\\n\\n## React Native (*Experimental*)\\n\\nRecoil should now work with the React Native environment.  However, similar to server side rendering, it is not officially supported. ([#114](https://github.com/facebookexperimental/Recoil/pull/114) - [@jacques-blom](https://github.com/jacques-blom), [@mondaychen](https://github.com/mondaychen))\\n\\n## Atom Effects (*Experimental*)\\n\\n[Effects for atoms](/docs/guides/atom-effects) simplifies managing side-effect policies for atoms on a per-atom basis as part of the `atom()` or `atomFamily()` definition.  Effects can be used for interesting applications such as [logging](/docs/guides/atom-effects#logging-example) and state synchronization or persistence with external storage such as [remote databases](/docs/guides/atom-effects#state-synchronization-example), [local storage](/docs/guides/atom-effects#local-storage-persistence), browser URL history, etc.  For example, you could use an atom as a local copy of some user state and provide an effect to subscribe to changes on a server to update the local copy and for local changes to write-through and update the server. ([#680](https://github.com/facebookexperimental/Recoil/pull/680), [#380](https://github.com/facebookexperimental/Recoil/pull/380), [#381](https://github.com/facebookexperimental/Recoil/pull/381), [#384](https://github.com/facebookexperimental/Recoil/pull/384), [#385](https://github.com/facebookexperimental/Recoil/pull/385), [#448](https://github.com/facebookexperimental/Recoil/pull/448), [#449](https://github.com/facebookexperimental/Recoil/pull/449), [#412](https://github.com/facebookexperimental/Recoil/pull/412), [#591](https://github.com/facebookexperimental/Recoil/pull/591), [#634](https://github.com/facebookexperimental/Recoil/pull/634), [#682](https://github.com/facebookexperimental/Recoil/pull/682) &#8212; [@drarmstr](https://github.com/drarmstr), [@csantos4242](https://github.com/csantos4242))\\n\\n## Snapshots for Testing (*Experimental*)\\n\\nSnapshots can now be [constructed outside of a React context](/docs/api-reference/core/Snapshot#building-a-snapshot).  This can be useful for [testing](/docs/guides/testing) or evaluating selectors outside of a React context. ([#649](https://github.com/facebookexperimental/Recoil/pull/649) &#8212; [@drarmstr](https://github.com/drarmstr), [@habond](https://github.com/habond))\\n\\n## Bug Fixes\\n\\n* This update has various bug fixes for testing and infrastructure. ([#555](https://github.com/facebookexperimental/Recoil/pull/555), [#587](https://github.com/facebookexperimental/Recoil/pull/587), [#588](https://github.com/facebookexperimental/Recoil/pull/588), [#590](https://github.com/facebookexperimental/Recoil/pull/590), [#635](https://github.com/facebookexperimental/Recoil/pull/635), [#631](https://github.com/facebookexperimental/Recoil/pull/631), [#683](https://github.com/facebookexperimental/Recoil/pull/683), [#684](https://github.com/facebookexperimental/Recoil/pull/684), [#686](https://github.com/facebookexperimental/Recoil/pull/686) &#8212; [@aaronabramov](https://github.com/aaronabramov), [@mondaychen](https://github.com/mondaychen), [@drarmstr](https://github.com/drarmstr), [@mallchel](https://github.com/mallchel), [@davidmccabe](https://github.com/davidmccabe), [@csantos4242](https://github.com/csantos4242))\\n* Do not freeze objects which should not be frozen. ([#597](https://github.com/facebookexperimental/Recoil/pull/597), [#633](https://github.com/facebookexperimental/Recoil/pull/633), [#672](https://github.com/facebookexperimental/Recoil/pull/672) &#8212; [@RinGoku](https://github.com/RinGoku), [@a-sane](https://github.com/a-sane))\\n* TypeScript typing for `Snapshot`. ([#687](https://github.com/facebookexperimental/Recoil/pull/687) &#8212; [@kevinfrei](https://github.com/kevinfrei), [@drarmstr](https://github.com/drarmstr), [@habond](https://github.com/habond))\\n* Additional testing for `waitForAll()` concurrency. ([#681](https://github.com/facebookexperimental/Recoil/pull/681) &#8212; [@drarmstr](https://github.com/drarmstr))\\n\\n## Future Work\\n\\nIn a future release, Recoil will automatically free the memory used by atoms and selectors that are no longer used, and will perform better with larger numbers of atoms. ([@davidmccabe](https://github.com/davidmccabe))\\n\\nReleasing our prototype Chrome developer tools. ([@maxijb](https://github.com/maxijb))\\n\\nLibraries of effects for common state persistence, such as browser local storage or URL history. ([@bezi](https://github.com/bezi))\\n\\nThanks for your continued interest in Recoil!"},{"id":"/2020/09/15/0.0.11-released","metadata":{"permalink":"/zh-hans/blog/2020/09/15/0.0.11-released","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2020-09-15-0.0.11-released.mdx","source":"@site/blog/2020-09-15-0.0.11-released.mdx","title":"Recoil 0.0.11","description":"Today we are releasing Recoil 0.0.11. It contains bug fixes, new features, better performance, and experimental compatibility with Concurrent Mode. Thank you so much to everyone who contributed to this release!","date":"2020-09-15T00:00:00.000Z","formattedDate":"2020\u5e749\u670815\u65e5","tags":[],"readingTime":5.15,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.1.1","permalink":"/zh-hans/blog/2020/10/30/0.1.1-released"},"nextItem":{"title":"Recoil 0.0.10","permalink":"/zh-hans/blog/2020/06/18/0.0.10-released"}},"content":"import useBaseUrl from \'@docusaurus/useBaseUrl\';\\n\\nToday we are releasing Recoil 0.0.11. It contains bug fixes, new features, better performance, and experimental compatibility with Concurrent Mode. Thank you so much to everyone who contributed to this release!\\n\x3c!--truncate--\x3e\\n## Experimental Concurrent Mode Support\\n\\nRecoil now supports [Concurrent Mode](https://reactjs.org/docs/concurrent-mode-intro.html) when used with the `experimental` release of React. Please try this out and report any problems!\\n\\nConcurrent Mode, which enables smoother, more consistent user experiences, is the future of React. But up until now it\'s been incompatible with any kind of external state. This is because, in Concurrent Mode, renders can be spread out over time: React can pause the rendering of components, then later pick up where it left off, starting from the partial component tree that it already built:\\n\\n<img alt=\\"React pauses while rendering a tree of components. Some components are rendered before the pause while others are rendered after the pause.\\" src={useBaseUrl(\'img/blog/2020-09-02-0.0.11-released/concurrent2.png\')} />\\n\\nThis presents a problem with external state. Since React now relinquishes control flow, anything could happen between the time when rendering starts and when it is completed. If the external state changes during this time, it will result in an inconsistent UI, as the earlier-rendered components will observe the older state, while the later-rendered components will observe the new state:\\n\\n<img alt=\\"If components depend on some external state, and that state changes while rendering is paused, then components rendered before the pause will observe the old state, while components rendered after the pause will observe the new state.\\" src={useBaseUrl(\'img/blog/2020-09-02-0.0.11-released/concurrent3.png\')} />\\n\\nThis inconsistency could cause problems up to crashing the app.\\n\\nRecoil now takes advantage of experimental APIs in React to handle this situation by restarting with a fresh tree when Recoil state has changed during a render. These APIs also make Recoil more efficient and remove the need to re-render components when they\'re first mounted.\\n\\nAvoid using React experimental releases in production.  And, no matter what release of React or state management library you use, [avoid bugs by always keeping side-effects in a `useEffect()` hook, not during render](https://gist.github.com/sebmarkbage/75f0838967cd003cd7f9ab938eb1958f)!  ([@davidmccabe](https://github.com/davidmccabe), [@bvaughn](https://github.com/bvaughn))\\n\\n## Performance\\n\\nSeveral changes improve Recoil\'s performance. Previously, Recoil sometimes had to re-render components in certain circumstances: when reading from selectors that had unknown dependencies and when reading from atoms that had been initialized from external storage. Now, Recoil never has to perform a second render in response to reading an atom or selector. ([@davidmccabe](https://github.com/davidmccabe))\\n\\nSecondly, when used with the `experimental` release of React, Recoil no longer has to perform a second render when components are initially mounted. Recoil also no longer has to do any work to look up atom or selector values when it re-renders for reasons other than that atom or selector changing. ([@davidmccabe](https://github.com/davidmccabe), [@bvaughn](https://github.com/bvaughn)).\\n\\nThe basic hooks such as `useRecoilValue()` and `useRecoilState()` have been optimized and are now about 8&#215; faster. They now typically take less than 2&#215; as long as `useState()` to execute. This improves the performance of apps that use a large number of atoms in many components. ([@davidmccabe](https://github.com/davidmccabe))\\n\\nRecoil recursively freezes the contents of atoms and selectors. This prevents bugs, but can be slow with large objects. It now happens only in the development build. ([#361](https://github.com/facebookexperimental/Recoil/pull/361) &#8212; [@drarmstr](https://github.com/drarmstr))\\n\\nRecoil now avoids re-rendering components or re-evaluating selectors if you set an atom to its already-set value or reset it when it is already reset ([#399](https://github.com/facebookexperimental/Recoil/pull/399), [#386](https://github.com/facebookexperimental/Recoil/pull/386) &#8212; [@drarmstr](https://github.com/drarmstr)).\\n\\nFinally, this release also fixes a memory leak introduced in the previous release. If you\'ve been experiencing poor performance in apps that frequently update atoms, this was likely the cause. ([#471](https://github.com/facebookexperimental/Recoil/pull/471) &#8212; [@davidmccabe](https://github.com/davidmccabe))\\n\\n## Types and Packaging\\n\\n[Flow types](https://flow.org/) are now exported with the package in addition to TypeScript. Flow is the type system used at Facebook and that Recoil is actually written in. ([#338](https://github.com/facebookexperimental/Recoil/pull/338), [#468](https://github.com/facebookexperimental/Recoil/pull/468), [#541](https://github.com/facebookexperimental/Recoil/pull/541) &#8212; [@Brianzchen](https://github.com/Brianzchen), [@Komalov](https://github.com/Komalov), [@mondaychen](https://github.com/mondaychen))\\n\\nTypeScript typing is also improved ([#492](https://github.com/facebookexperimental/Recoil/pull/492), [#545](https://github.com/facebookexperimental/Recoil/pull/545), [#548](https://github.com/facebookexperimental/Recoil/pull/548), [#568](https://github.com/facebookexperimental/Recoil/pull/568), [#575](https://github.com/facebookexperimental/Recoil/pull/575) &#8212; [@csantos42](https://github.com/csantos42), [@SergeyVolynkin](https://github.com/SergeyVolynkin), [@drarmstr](https://github.com/drarmstr), [@hachibeeDI](https://github.com/hachibeeDI)).\\n\\nIn addition to NPM packages, we now provide [Common JS and UMD modules via CDN](/docs/introduction/installation#cdn) ([#413](https://github.com/facebookexperimental/Recoil/pull/413) &#8212; [@mondaychen](https://github.com/mondaychen), [@pocket7878](https://github.com/pocket7878)).\\n\\n## Support for Multiple React Roots\\n\\nYou can now [share state between multiple React roots](/docs/api-reference/core/useRecoilBridgeAcrossReactRoots).  For example, if your app uses both React DOM and another renderer such as ThreeJS, you can now share Recoil state between them. As always when using multiple React roots, they may be momentarily out of sync. ([#298](https://github.com/facebookexperimental/Recoil/pull/298), [#516](https://github.com/facebookexperimental/Recoil/pull/516) &#8212; [@drarmstr](https://github.com/drarmstr), [@inlet](https://github.com/inlet))\\n\\n## Developer Tool APIs\\n\\nThis release includes [experimental APIs](/docs/api-reference/core/Snapshot#developer-tools) intended for developer tools. We are creating a set of developer tools internally and there are also multiple open-source projects underway. We are releasing these APIs to help validate their design. ([@drarmstr](https://github.com/drarmstr))\\n\\n## Other New APIs\\n\\nYou can now use a Promise as the default value of an atom. When read it will behave like an async selector. ([@drarmstr](https://github.com/drarmstr))\\n\\n## Bug Fixes\\n\\nThis update has many fixes related to test infrastructure and differences between the open-source and Facebook-internal environments. ([#368](https://github.com/facebookexperimental/Recoil/pull/368), [#360](https://github.com/facebookexperimental/Recoil/pull/360), [#362](https://github.com/facebookexperimental/Recoil/pull/362), [#363](https://github.com/facebookexperimental/Recoil/pull/363), [#392](https://github.com/facebookexperimental/Recoil/pull/392), [#431](https://github.com/facebookexperimental/Recoil/pull/431), [#402](https://github.com/facebookexperimental/Recoil/pull/402), [#538](https://github.com/facebookexperimental/Recoil/pull/538), [#539](https://github.com/facebookexperimental/Recoil/pull/539), [#549](https://github.com/facebookexperimental/Recoil/pull/549), [#561](https://github.com/facebookexperimental/Recoil/pull/561), [#576](https://github.com/facebookexperimental/Recoil/pull/576) &#8212; [@aaronabramov](https://github.com/aaronabramov), [@Komalov](https://github.com/Komalov), [@drarmstr](https://github.com/drarmstr), [@jacques-blom](https://github.com/jacques-blom), [@mondaychen](https://github.com/mondaychen), [@dsainati1](https://github.com/dsainati1), [@csantos42](https://github.com/csantos42), [@behnammodi](https://github.com/behnammodi), [@habond](https://github.com/habond), [@benhalverson](https://github.com/benhalverson)).\\n\\nIt also fixes bugs when using multiple `<RecoilRoot>`s or pre-loading selectors in a snapshot ([#534](https://github.com/facebookexperimental/Recoil/pull/534) &#8212; [@davemccabe](https://github.com/davemccabe)).\\n\\n## Breaking Changes\\n\\nThis update may break certain tests that don\'t use the [`act()` function from `react-test-utils`](https://reactjs.org/docs/test-utils.html#act) to perform actions affecting React components. These tests sometimes worked anyway due to Recoil\'s extra renders. Use `act()` to fix any such tests.\\n\\nRecoil will now throw an exception if a state updater function provided to Recoil causes another atom update within its own execution. State updater functions are supposed to be pure, so this has always been against the API contract. But it happened to work in some cases before, and now it doesn\'t. Code that does this can be changed to perform the effects with `useRecoilCallback()`.\\n\\n## Future Work\\n\\nIn a future release, Recoil will automatically free the memory used by atoms and selectors that are no longer used, and will perform better with larger numbers of atoms. ([@davidmccabe](https://github.com/davidmccabe))\\n\\nWe are also working on APIs for synchronizing Recoil atoms with external data sources such as the URL, local storage, or a server. ([@drarmstr](https://github.com/drarmstr))\\n\\nDeveloper tools are in development. ([@maxijb](https://github.com/maxijb), [@habond](https://github.com/habond), [@drarmstr](https://github.com/drarmstr))\\n\\nThanks for reading this far and for using Recoil! More releases are coming soon."},{"id":"/2020/06/18/0.0.10-released","metadata":{"permalink":"/zh-hans/blog/2020/06/18/0.0.10-released","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2020-06-18-0.0.10-released.md","source":"@site/blog/2020-06-18-0.0.10-released.md","title":"Recoil 0.0.10","description":"Recoil 0.0.9 and 0.0.10 is being released with some bug fixes, TypeScript support, and a new API for Recoil Snapshots to observe, inspect, and manage global Recoil atom state.  Thanks again to everyone who helped make this possible and stay tuned for more exciting developments coming soon!","date":"2020-06-18T00:00:00.000Z","formattedDate":"2020\u5e746\u670818\u65e5","tags":[],"readingTime":7.44,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.0.11","permalink":"/zh-hans/blog/2020/09/15/0.0.11-released"},"nextItem":{"title":"Recoil 0.0.8","permalink":"/zh-hans/blog/2020/05/30/0.0.8-released"}},"content":"Recoil 0.0.9 and 0.0.10 is being released with some bug fixes, [TypeScript support](#typescript-support), and a new API for [Recoil Snapshots](#recoil-snapshots) to observe, inspect, and manage global Recoil atom state.  Thanks again to everyone who helped make this possible and stay tuned for more exciting developments coming soon!\\n\\n\x3c!--truncate--\x3e\\n\\n## Bug Fixes\\n\\n- Fixes for Server Side Rendering, though we do not officially support it yet. (#233, #220, #284) - Thanks @fyber-LJX, @Chrischuck, and @aulneau\\n- Fix selectors recording dependency subscriptions in some cases (#296) - Thanks @drarmstr\\n- Fix updaters in `useRecoilCallback()` getting current state (#260) - Thanks @drarmstr\\n- Fix error messages when throwing certain errors in the open-source build. (#199) - Thanks @jonthomp\\n- Reduce Flow errors for open-source builds (#308) - Thanks @Komalov\\n\\n## Improvements\\n\\n- Throw error with meaningful message if user doesn\'t use an atom or selector with most Recoil hooks (#205) - Thanks @alexandrzavalii\\n- Improve testing (#321, #318, #294, #262, #295) - Thanks @aaronabramov, @Komalov, @mondaychen, @drarmstr, and @tyler-mitchell\\n- Improve open-source build (#249, #203, #33) - Thanks to @tony-go, @acutmore, and @jaredpalmer\\n\\n## TypeScript support\\n\\nTypeScript support is being rolled into the Recoil GitHub repository instead of `DefinitelyTyped` to help better keep it in sync with the API. (#292 & #339) - Thanks @csantos42\\n\\n# Recoil Snapshots\\n\\n#312, #311, #310, #309, #260, #259, #258, #257, #256 - Thanks @drarmstr and the rest of the team\\n\\nWe are introducing the concept of a [`Snapshot`](/docs/api-reference/core/Snapshot) to Recoil.  A `Snapshot` is an immutable snapshot of the state of Recoil atoms.  This is intended to standardize the API for observing, inspecting, and managing global Recoil state and derived state.  It\u2019s useful for dev tools, global state synchronization, history, and navigation.\\n\\n## API\\n\\n### Reading Snapshots\\n\\nThe `Snapshot` class exposes the following methods for getting the values of individual Recoil atoms and selectors:\\n\\n```jsx\\nclass Snapshot {\\n  getLoadable: <T>(RecoilValue<T>) => Loadable<T>;\\n  getPromise: <T>(RecoilValue<T>) => Promise<T>;\\n  ...\\n}\\n```\\n\\nSnapshots are read-only with respect to atom state.  They can be used to read atom state and evaluate selector derived state.  For asynchronous selectors, the `getPromise()` method can be used to wait for the evaluated value so you can see what the selector value would be based on the static atom state.\\n\\n### Transforming Snapshots\\n\\nThere are cases where you may wish to mutate a snapshot.  While snapshots are immutable, they have methods to map themselves with a set of transformations to a new immutable snapshot.  The map methods take a callback that is passed a `MutableSnapshot`, which is mutated throughout the callback and will ultimately become the new snapshot returned by the mapping operation.\\n\\n```jsx\\nclass Snapshot {\\n  ...\\n  map: (MutableSnapshot => void) => Snapshot;\\n  asyncMap: (MutableSnapshot => Promise<void>) => Promise<Snapshot>;\\n}\\n\\nclass MutableSnapshot {\\n  set: <T>(RecoilState<T>, T | DefaultValue | (T => T | DefaultValue)) => void;\\n  reset: <T>(RecoilState<T>) => void;\\n}\\n```\\n\\nNotice that `set()` and `reset()` have the same signature as the callbacks provided to a writeable selector\u2019s `set()` function.\\n\\n**Example**\\n\\n```jsx\\n  const newSnapshot = snapshot.map(({set}) => set(myAtom, 42));\\n```\\n\\n## Hooks\\n\\nRecoil has the following hooks for working with snapshots:\\n\\n* [**`useRecoilSnapshot()`**](/docs/api-reference/core/useRecoilSnapshot) - Synchronous access to snapshot\\n* [**`useRecoilCallback()`**](/docs/api-reference/core/useRecoilCallback) - Asynchronous access to snapshot\\n* [**`useRecoilTransactionObserver()`**](/docs/api-reference/core/useRecoilTransactionObserver) - Subscribe to snapshots of all state updates\\n* [**`useGotoRecoilSnapshot()`**](/docs/api-reference/core/useGotoRecoilSnapshot) - Update current state to match snapshot\\n\\n### useRecoilSnapshot()\\n\\n```jsx\\nfunction useRecoilSnapshot(): Snapshot\\n```\\n\\nYou can use this hook to synchronously obtain a snapshot to the current state while rendering a component.  While conceptually simple, this hook will subscribe any component that uses it to any Recoil state change so it always renders with a snapshot of the current state.  Therefore, be careful using this hook.  One example when you may want to use it is for supporting server-side rendering where you need to synchronously have the state with the first render.  In the future, we may provide the ability to debounce for performance.\\n\\n**Example**\\n\\nDefine a `<LinkToNewState>` component that renders an `<a>` anchor with an `href` based on the current state with a mutation applied.  In this example `uriFromSnapshot()` is some user-defined function which encodes the current state in the URI which can be restored when loading the page.\\n\\n```jsx\\nfunction LinkToNewState() {\\n  const snapshot = useRecoilSnapshot();\\n  const newSnapshot = snapshot.map(({set}) => set(myAtom, 42));\\n  return <a href={uriFromSnapshot(newSnapshot)}>Click Me!</a>;\\n}\\n```\\n\\nThis is a simplified example.  We have a helper like this for generating links in our browser history persistence library coming soon which is more extensible and optimized.  For example, it will hijack the click handler to update local state without needing to go through the browser history.\\n\\n### useRecoilCallback()\\n\\n```jsx\\ntype CallbackInterface = {\\n  snapshot: Snapshot,\\n  gotoSnapshot: Snapshot => void,\\n  set: <T>(RecoilState<T>, (T => T) | T) => void,\\n  reset: <T>(RecoilState<T>) => void,\\n};\\n\\nfunction useRecoilCallback<Args, Return>(\\n  callback: CallbackInterface => (...Args) => ReturnValue,\\n  deps?: $ReadOnlyArray<mixed>,\\n): (...Args) => ReturnValue\\n```\\n\\nThe `useRecoilCallback()` hook is similar to the React [`useCallback()`](https://reactjs.org/docs/hooks-reference.html#usecallback) hook for producing a callback function.  But, instead of just providing an input callback function you wrap it with a function providing a callback interface parameter that gives you access to a `Snapshot` and `set()`/`reset()` callbacks to update the current global state.  The provided `Snapshot` represents the state when the callback is called, not when the callback function was originally created.\\n\\nNOTE: This is a slight breaking change in the API, but we are still on version `0.0.x` of Recoil and haven\u2019t fully started semantic versioning yet.\\n\\n`useRecoilCallback()` also takes an optional `deps` array parameter for controlling memoization.  You can extend the `react-hooks/exhaustive-deps` lint rule for ensuring this is properly used.\\n\\nSome motivations for using `useRecoilCallback()`:\\n\\n* Asynchronously use Recoil state without subscribing a React component to re-render if the atom or selector is updated.\\n* Deferring expensive lookups to an async action that you don\'t want to do at render-time.\\n\\n* Performing side-effects where you would like to also read or write to Recoil state.\\n* Dynamically updating an atom or selector where we may not know at render-time which atom or selector we will want to update, so we can\'t use [`useSetRecoilState()`](https://recoiljs.org/docs/api-reference/core/useSetRecoilState).\\n* Pre-fetching before rendering\\n\\n\\n**Example**\\n\\nButton component which will evaluate an expensive selector when clicked on.\\n\\n```jsx\\nfunction ShowDetailsButton() {\\n  const onClick = useRecoilCallback(({snapshot}) => async () => {\\n    const data = await snapshot.getPromise(expensiveQuery);\\n    showPopup(data);\\n  });\\n\\n  return <button onClick={onClick}>Show Details</button>;\\n}\\n```\\n\\n### useRecoilTransactionObserver()\\n\\n```jsx\\nfunction useRecoilTransactionObserver_UNSTABLE(({\\n  snapshot: Snapshot,\\n  previousSnapshot: Snapshot,\\n}) => void)\\n```\\n\\nThis hook subscribes a callback to be executed every time there is a change to Recoil atom state.  Multiple updates may be batched together in a single transaction.  This hook is great for persisting state changes, dev tools, building history, &c.  In the future, we may allow the ability to subscribe to specific conditions or provide debouncing for performance.\\n\\n**Debug Observer Example**\\n\\n```jsx\\nfunction DebugObserver() {\\n  useRecoilTransactionObserver_UNSTABLE(({snapshot}) => {\\n    window.myDebugState = {\\n      a: snapshot.getLoadable(atomA).contents,\\n      b: snapshot.getLoadable(atomB).contents,\\n    };\\n  });\\n  return null;\\n}\\n```\\n\\n### useGotoRecoilState()\\n\\n```jsx\\nfunction useGotoRecoilSnapshot(): Snapshot => void\\n```\\n\\nThis hook returns a callback which takes a `Snapshot` as a parameter and will update the current `<RecoilRoot>` state to match this atom state.\\n\\n**Time Travel Example**\\n\\nExample list of history of state changes with the ability to go back and restore previous state.\\n\\n```jsx\\nfunction TimeTravelObserver() {\\n  const [snapshots, setSnapshots] = useState([]);\\n\\n  useRecoilTransactionObserver_UNSTABLE(({snapshot}) => {\\n    setSnapshots([...snapshots, snapshot]);\\n  });\\n\\n  const gotoSnapshot = useGotoRecoilSnapshot();\\n\\n  return (\\n    <ol>\\n      {snapshots.map((snapshot, i) => (\\n        <li key={i}>\\n          Snapshot {i}\\n          <button onClick={() => gotoSnapshot(snapshot)}>\\n            Restore\\n          </button>\\n        </li>\\n      )}\\n    </ol>\\n  );\\n}\\n```\\n\\n## State Initialization\\n\\nThe `<RecoilRoot>` component also has an `initializeState` prop which can be used to initialize the atom state.  This prop takes a function with a `MutableSnapshot` parameter that can be used to setup the initial atom state.  This can be helpful for loading persisted state when you know all atoms in advance.  It can be useful for server-side rendering where the state should be setup synchronously for the first render.\\n\\n**Example**\\n\\n```jsx\\nfunction MyApp() {\\n  return (\\n    <RecoilRoot\\n      initializeState={({set}) => {\\n        for (const [atom, value] of atoms) {\\n          set(atom, value);\\n        }\\n      }}\\n    >\\n      <AppContents />\\n    </RecoilRoot>\\n  );\\n}\\n```\\n\\n## What\u2019s Next?\\n\\nSnapshots allow us to observe and synchronize the global state.  But, what if we want a more granular and composable system to work with individual atoms?  We\u2019re working on the concept of *Atom Effects* for observing and dealing with side-effects at the atom level.  This will make it easier to persist state or bi-directionally sync with mutable storage.  Think of synchronizing state with the browser URI history, browser local storage, RESTful APIs, &c.  Coming soon!\\n\\nThe `Snapshot` API introduced here allows us to inspect the current state for individual atoms and selectors.  We\u2019ll be expanding the API to be able to inspect the set of available nodes and explore the data-flow graph structure.  This will be powerful for building dev tools.  Stay tuned!\\n\\nAnd, of course, we still have exiciting support for React Concurrent Mode and improved speed, scalability, and memory management in the works."},{"id":"/2020/05/30/0.0.8-released","metadata":{"permalink":"/zh-hans/blog/2020/05/30/0.0.8-released","editUrl":"https://github.com/facebookexperimental/Recoil/edit/docs/docs/blog/blog/2020-05-30-0.0.8-released.md","source":"@site/blog/2020-05-30-0.0.8-released.md","title":"Recoil 0.0.8","description":"Today we are releasing Recoil 0.0.8. It contains bug fixes and new features. Thanks so much to everyone who contributed to this release! It\'s been amazing to see so many people contribute.","date":"2020-05-30T00:00:00.000Z","formattedDate":"2020\u5e745\u670830\u65e5","tags":[],"readingTime":3.075,"truncated":true,"authors":[],"prevItem":{"title":"Recoil 0.0.10","permalink":"/zh-hans/blog/2020/06/18/0.0.10-released"}},"content":"Today we are releasing Recoil 0.0.8. It contains bug fixes and new features. Thanks so much to everyone who contributed to this release! It\'s been amazing to see so many people contribute.\\n\\n\x3c!--truncate--\x3e\\n\\n## Bug Fixes\\n\\n- Fixed a bug where atoms that stored self-referential structures would cause an infinite loop. (@n3tr in #153)\\n- Fixed bugs affecting Server-Side Rendering. (@sbaudray in #53)\\n- Fixed build system and repository syncing problems. Many people contributed to this, especially @mondaychen and including\\n@claudiopro, @dustinsoftware, @jacques-blom, @jaredpalmer, @kentcdodds, @leushkin, and @tony-go. It remains to get Jest and Flow to behave the same between internal and OSS.\\n\\n## Features\\n\\n### TypeScript support\\n\\nTypeScript definitions are now available via the `DefinitelyTyped` repository.\\n\\n### `atomFamily` and `selectorFamily`\\n\\nThese utilities help you create collections of related atoms or selectors, one for each value of some parameter. Instaed of manually creating a memoized function that returns an atom or selector, you can use `atomFamily` and `selectorFamily`. In the future, these utilities will also help with memory management.\\n\\nThe `atomFamily` function returns a function from some parameter to an atom, creating a new atom for each value of the parameter that is passed in. For example, suppose you wanted to store a set of coordinates `{x: number, y: number}` for every member of a collection identified by some `ID`. Then you could write:\\n\\n```jsx\\nconst coordinatesForID = atomFamily<{x: number, y: number}, ID>({\\n    key: \'coordinatesForID\',\\n    default: {x: 0, y: 0},\\n});\\n```\\n\\nand then access that state as follows:\\n\\n```jsx\\nfunction MyComponent({id}) {\\n    const [coordinates, setCoordinates] = useRecoilState(\\n        coordinatesForID(id)\\n    );\\n    ...\\n}\\n```\\n\\nEach `ID` passed to `coordinatesForID` will get its own independent atom containing the coordinates. Each of these atoms has its own subscriptions, so a component that uses the state for a single ID will only be subscribed to changes to that one ID.\\n\\nSimilarly, `selectorFamily` lets you create a different selector for each value of some parameter. For example, suppose you wanted to take each of those coordinates and rotate them by 180 degrees:\\n\\n```jsx\\nconst rotatedCoordinatesForID = selectorFamily<{x: number, y: number}, ID>({\\n    key: \'rotatedCoordinatesForID\',\\n    get: id => ({get}) => {\\n        const coordinates = get(coordinatesForID(id));\\n        return {\\n            x: -coordinates.x,\\n            y: -coordinates.y,\\n        };\\n    }\\n});\\n```\\n\\nNote that the `get` property of a selector family is a function that takes the parameter (in this case ID) and returns a function with a signature identical to the `get` property of a single selector. In general, this is how all of the options for atom families and selector families work.\\n\\n### Concurrency helpers\\n\\nWe\'ve introduced selector families for controlling concurrency in async selectors:\\n\\n- `waitForAll`: requests all dependencies in parallel and waits for all of them to become available.\\n- `waitForAny`: requests all dependencies in parallel and waits for any one of them to become available.\\n- `waitForNone`: requests all dependencies in parallel but doesn\'t wait for any of them.\\n- `noWait` requests a single dependency but doesn\'t wait for it to become available.\\n\\nThese can be used to retireve multiple dependencies in parallel and to write logic conditional on the status of an upstream dependency. For example, you can write a selector that conditionally provides a default value while an async process is in flight instead of propagating that loading state down to components.\\n\\n### `constSelector` and `errorSelector`\\n\\nThese selector families simply return a constant value or always throw a given error, respectively.\\n\\n### readOnlySelector\\n\\nThis simply wraps a read-write `RecoilState` in a read-only interface.\\n\\n## What\'s Next\\n\\nWe\'re working on improvements to the observation and persistence APIs, improved speed and memory management, and support for Concurrent Mode. Thanks so much for trying Recoil, we hope you\'ll stick around and see what it becomes!"}]}')}}]);