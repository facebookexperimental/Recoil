!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?factory(exports,require("react-dom"),require("react")):"function"==typeof define&&define.amd?define(["exports","react-dom","react"],factory):factory((global=global||self).Recoil={},global.ReactDOM,global.React)}(this,(function(exports,reactDom,react){"use strict";reactDom=reactDom&&Object.prototype.hasOwnProperty.call(reactDom,"default")?reactDom.default:reactDom,react=react&&Object.prototype.hasOwnProperty.call(react,"default")?react.default:react;var Recoil_isPromise=function(p){return!!p&&"function"==typeof p.then};var Recoil_nullthrows=function(x,message){if(null!=x)return x;throw new Error(null!=message?message:"Got unexpected null or undefined")};class Canceled{}const CANCELED=new Canceled,loadableAccessors={valueMaybe(){},valueOrThrow(){throw new Error(`Loadable expected value, but in "${this.state}" state`)},errorMaybe(){},errorOrThrow(){throw new Error(`Loadable expected error, but in "${this.state}" state`)},promiseMaybe(){},promiseOrThrow(){throw new Error(`Loadable expected promise, but in "${this.state}" state`)},is(other){return other.state===this.state&&other.contents===this.contents},map(map){if("hasError"===this.state)return this;if("hasValue"===this.state)try{const next=map(this.contents);return Recoil_isPromise(next)?loadableWithPromise(next):loadableWithValue(next)}catch(e){return Recoil_isPromise(e)?loadableWithPromise(e.next(()=>map(this.contents))):loadableWithError(e)}if("loading"===this.state)return loadableWithPromise(this.contents.then(map).catch(e=>{if(Recoil_isPromise(e))return e.then(()=>map(this.contents));throw e}));throw new Error("Invalid Loadable state")}};function loadableWithValue(value){return Object.freeze({state:"hasValue",contents:value,...loadableAccessors,getValue(){return this.contents},toPromise(){return Promise.resolve(this.contents)},valueMaybe(){return this.contents},valueOrThrow(){return this.contents}})}function loadableWithError(error){return Object.freeze({state:"hasError",contents:error,...loadableAccessors,getValue(){throw this.contents},toPromise(){return Promise.reject(this.contents)},errorMaybe(){return this.contents},errorOrThrow(){return this.contents}})}function loadableWithPromise(promise){return Object.freeze({state:"loading",contents:promise,...loadableAccessors,getValue(){throw this.contents.then(({__value:__value})=>__value)},toPromise(){return this.contents.then(({__value:__value})=>__value)},promiseMaybe(){return this.contents.then(({__value:__value})=>__value)},promiseOrThrow(){return this.contents.then(({__value:__value})=>__value)}})}var Recoil_Loadable={loadableWithValue:loadableWithValue,loadableWithError:loadableWithError,loadableWithPromise:loadableWithPromise,loadableLoading:function(){return loadableWithPromise(new Promise(()=>{}))},loadableAll:function(inputs){return inputs.every(i=>"hasValue"===i.state)?loadableWithValue(inputs.map(i=>i.contents)):inputs.some(i=>"hasError"===i.state)?loadableWithError(Recoil_nullthrows(inputs.find(i=>"hasError"===i.state),"Invalid loadable passed to loadableAll").contents):loadableWithPromise(Promise.all(inputs.map(i=>i.contents)).then(value=>({__value:value})))},Canceled:Canceled,CANCELED:CANCELED};var Recoil_recoverableViolation=function(message,projectName,{error:error}={}){return null};var Recoil_CopyOnWrite={setByAddingToSet:function(set,v){const next=new Set(set);return next.add(v),next},setByDeletingFromSet:function(set,v){const next=new Set(set);return next.delete(v),next},mapBySettingInMap:function(map,k,v){const next=new Map(map);return next.set(k,v),next},mapByUpdatingInMap:function(map,k,updater){const next=new Map(map);return next.set(k,updater(next.get(k))),next},mapByDeletingFromMap:function(map,k){const next=new Map(map);return next.delete(k),next},mapByDeletingMultipleFromMap:function(map,ks){const next=new Map(map);return ks.forEach(k=>next.delete(k)),next}};var Recoil_filterIterable=function*(iterable,predicate){let index=0;for(const value of iterable)predicate(value,index++)&&(yield value)};const gks=(new Map).set("recoil_hamt_2020",!0).set("recoil_memory_managament_2020",!0);function Recoil_gkx(gk){var _gks$get;return null!==(_gks$get=gks.get(gk))&&void 0!==_gks$get&&_gks$get}Recoil_gkx.setPass=gk=>{gks.set(gk,!0)},Recoil_gkx.setFail=gk=>{gks.set(gk,!1)};var Recoil_gkx_1=Recoil_gkx;var Recoil_mapIterable=function(iterable,callback){return function*(){let index=0;for(const value of iterable)yield callback(value,index++)}()};function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}class AbstractRecoilValue{constructor(newKey){_defineProperty(this,"key",void 0),this.key=newKey}}class RecoilState extends AbstractRecoilValue{}class RecoilValueReadOnly extends AbstractRecoilValue{}var Recoil_RecoilValue={AbstractRecoilValue:AbstractRecoilValue,RecoilState:RecoilState,RecoilValueReadOnly:RecoilValueReadOnly,isRecoilValue:function(x){return x instanceof RecoilState||x instanceof RecoilValueReadOnly}},Recoil_RecoilValue_1=Recoil_RecoilValue.AbstractRecoilValue,Recoil_RecoilValue_2=Recoil_RecoilValue.RecoilState,Recoil_RecoilValue_3=Recoil_RecoilValue.RecoilValueReadOnly,Recoil_RecoilValue_4=Recoil_RecoilValue.isRecoilValue,Recoil_RecoilValue$1=Object.freeze({__proto__:null,AbstractRecoilValue:Recoil_RecoilValue_1,RecoilState:Recoil_RecoilValue_2,RecoilValueReadOnly:Recoil_RecoilValue_3,isRecoilValue:Recoil_RecoilValue_4});class DefaultValue{}const DEFAULT_VALUE=new DefaultValue;class RecoilValueNotReady extends Error{constructor(key){super(`Tried to set the value of Recoil selector ${key} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const nodes=new Map,recoilValues=new Map;class NodeMissingError extends Error{}const configDeletionHandlers=new Map;function getConfigDeletionHandler(key){return configDeletionHandlers.get(key)}var Recoil_Node={nodes:nodes,recoilValues:recoilValues,registerNode:function(node){if(nodes.has(node.key)){const message=`Duplicate atom key "${node.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(message)}nodes.set(node.key,node);const recoilValue=null==node.set?new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key):new Recoil_RecoilValue$1.RecoilState(node.key);return recoilValues.set(node.key,recoilValue),recoilValue},getNode:function(key){const node=nodes.get(key);if(null==node)throw new NodeMissingError(`Missing definition for RecoilValue: "${key}""`);return node},getNodeMaybe:function(key){return nodes.get(key)},deleteNodeConfigIfPossible:function(key){var _node$shouldDeleteCon;if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;const node=nodes.get(key);var _getConfigDeletionHan;(null==node||null===(_node$shouldDeleteCon=node.shouldDeleteConfigOnRelease)||void 0===_node$shouldDeleteCon?void 0:_node$shouldDeleteCon.call(node))&&(nodes.delete(key),null===(_getConfigDeletionHan=getConfigDeletionHandler(key))||void 0===_getConfigDeletionHan||_getConfigDeletionHan(),configDeletionHandlers.delete(key))},setConfigDeletionHandler:function(key,fn){Recoil_gkx_1("recoil_memory_managament_2020")&&(void 0===fn?configDeletionHandlers.delete(key):configDeletionHandlers.set(key,fn))},getConfigDeletionHandler:getConfigDeletionHandler,recoilValuesForKeys:function(keys){return Recoil_mapIterable(keys,key=>Recoil_nullthrows(recoilValues.get(key)))},NodeMissingError:NodeMissingError,DefaultValue:DefaultValue,DEFAULT_VALUE:DEFAULT_VALUE,RecoilValueNotReady:RecoilValueNotReady};class RetentionZone{}var Recoil_RetentionZone={RetentionZone:RetentionZone,retentionZone:function(){return new RetentionZone}};const{setByAddingToSet:setByAddingToSet$1}=Recoil_CopyOnWrite,{getNode:getNode$1,getNodeMaybe:getNodeMaybe$1,recoilValuesForKeys:recoilValuesForKeys$1}=Recoil_Node,{RetentionZone:RetentionZone$1}=Recoil_RetentionZone,emptySet=Object.freeze(new Set);class ReadOnlyRecoilValueError extends Error{}function initializeNodeIfNewToStore(store,treeState,key,trigger){const storeState=store.getState();if(storeState.nodeCleanupFunctions.has(key))return;const config=getNode$1(key),retentionCleanup=function(store,nodeKey,retainedBy){if(!Recoil_gkx_1("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:nodesRetainedByZone}=store.getState().retention;function addToZone(zone){let set=nodesRetainedByZone.get(zone);set||nodesRetainedByZone.set(zone,set=new Set),set.add(nodeKey)}if(retainedBy instanceof RetentionZone$1)addToZone(retainedBy);else if(Array.isArray(retainedBy))for(const zone of retainedBy)addToZone(zone);return()=>{if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;const nodesRetainedByZone=store.getState().retention.nodesRetainedByZone;function deleteFromZone(zone){const set=nodesRetainedByZone.get(zone);set&&set.delete(nodeKey),set&&0===set.size&&nodesRetainedByZone.delete(zone)}if(retainedBy instanceof RetentionZone$1)deleteFromZone(retainedBy);else if(Array.isArray(retainedBy))for(const zone of retainedBy)deleteFromZone(zone)}}(store,key,config.retainedBy),nodeCleanup=config.init(store,treeState,trigger);storeState.nodeCleanupFunctions.set(key,()=>{nodeCleanup(),retentionCleanup()})}function peekNodeLoadable(store,state,key){return getNode$1(key).peek(store,state)}function getDownstreamNodes(store,state,keys){const visitedNodes=new Set,visitingNodes=Array.from(keys),graph=store.getGraph(state.version);for(let key=visitingNodes.pop();key;key=visitingNodes.pop()){var _graph$nodeToNodeSubs;visitedNodes.add(key);const subscribedNodes=null!==(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(key))&&void 0!==_graph$nodeToNodeSubs?_graph$nodeToNodeSubs:emptySet;for(const downstreamNode of subscribedNodes)visitedNodes.has(downstreamNode)||visitingNodes.push(downstreamNode)}return visitedNodes}var Recoil_FunctionalCore={getNodeLoadable:function(store,state,key){return initializeNodeIfNewToStore(store,state,key,"get"),getNode$1(key).get(store,state)},peekNodeLoadable:peekNodeLoadable,setNodeValue:function(store,state,key,newValue){const node=getNode$1(key);if(null==node.set)throw new ReadOnlyRecoilValueError("Attempt to set read-only RecoilValue: "+key);const set=node.set;return initializeNodeIfNewToStore(store,state,key,"set"),set(store,state,newValue)},cleanUpNode:function(store,key){var _state$nodeCleanupFun;const state=store.getState();null===(_state$nodeCleanupFun=state.nodeCleanupFunctions.get(key))||void 0===_state$nodeCleanupFun||_state$nodeCleanupFun(),state.nodeCleanupFunctions.delete(key)},setUnvalidatedAtomValue_DEPRECATED:function(state,key,newValue){var _node$invalidate;const node=getNodeMaybe$1(key);return null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),{...state,atomValues:state.atomValues.clone().delete(key),nonvalidatedAtoms:state.nonvalidatedAtoms.clone().set(key,newValue),dirtyAtoms:setByAddingToSet$1(state.dirtyAtoms,key)}},peekNodeInfo:function(store,state,key){var _graph$nodeDeps$get,_storeState$nodeToCom,_storeState$nodeToCom2;const storeState=store.getState(),graph=store.getGraph(state.version),type=storeState.knownAtoms.has(key)?"atom":storeState.knownSelectors.has(key)?"selector":void 0,downstreamNodes=Recoil_filterIterable(getDownstreamNodes(store,state,new Set([key])),nodeKey=>nodeKey!==key);return{loadable:peekNodeLoadable(store,state,key),isActive:storeState.knownAtoms.has(key)||storeState.knownSelectors.has(key),isSet:"selector"!==type&&state.atomValues.has(key),isModified:state.dirtyAtoms.has(key),type:type,deps:recoilValuesForKeys$1(null!==(_graph$nodeDeps$get=graph.nodeDeps.get(key))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:[]),subscribers:{nodes:recoilValuesForKeys$1(downstreamNodes),components:Recoil_mapIterable(null!==(_storeState$nodeToCom=null===(_storeState$nodeToCom2=storeState.nodeToComponentSubscriptions.get(key))||void 0===_storeState$nodeToCom2?void 0:_storeState$nodeToCom2.values())&&void 0!==_storeState$nodeToCom?_storeState$nodeToCom:[],([name])=>({name:name}))}}},getDownstreamNodes:getDownstreamNodes,initializeNodeIfNewToStore:initializeNodeIfNewToStore};const{CANCELED:CANCELED$1}=Recoil_Loadable,{getDownstreamNodes:getDownstreamNodes$1,getNodeLoadable:getNodeLoadable$1,setNodeValue:setNodeValue$1}=Recoil_FunctionalCore,{getNodeMaybe:getNodeMaybe$2}=Recoil_Node,{DefaultValue:DefaultValue$1,RecoilValueNotReady:RecoilValueNotReady$1}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,RecoilValueReadOnly:RecoilValueReadOnly$1,isRecoilValue:isRecoilValue$1}=Recoil_RecoilValue$1;function applyAction(store,state,action){if("set"===action.type){const{recoilValue:recoilValue,valueOrUpdater:valueOrUpdater}=action,newValue=function(store,state,{key:key},valueOrUpdater){if("function"==typeof valueOrUpdater){const current=getNodeLoadable$1(store,state,key);if("loading"===current.state)throw new RecoilValueNotReady$1(key);if("hasError"===current.state)throw current.contents;return valueOrUpdater(current.contents)}return valueOrUpdater}(store,state,recoilValue,valueOrUpdater),writes=setNodeValue$1(store,state,recoilValue.key,newValue);for(const[key,loadable]of writes.entries())writeLoadableToTreeState(state,key,loadable)}else if("setLoadable"===action.type){const{recoilValue:{key:key},loadable:loadable}=action;writeLoadableToTreeState(state,key,loadable)}else if("markModified"===action.type){const{recoilValue:{key:key}}=action;state.dirtyAtoms.add(key)}else if("setUnvalidated"===action.type){var _node$invalidate;const{recoilValue:{key:key},unvalidatedValue:unvalidatedValue}=action,node=getNodeMaybe$2(key);null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),state.atomValues.delete(key),state.nonvalidatedAtoms.set(key,unvalidatedValue),state.dirtyAtoms.add(key)}else Recoil_recoverableViolation("Unknown action "+action.type)}function writeLoadableToTreeState(state,key,loadable){"hasValue"===loadable.state&&loadable.contents instanceof DefaultValue$1?state.atomValues.delete(key):state.atomValues.set(key,loadable),state.dirtyAtoms.add(key),state.nonvalidatedAtoms.delete(key)}function applyActionsToStore(store,actions){store.replaceState(state=>{const newState=function(state){return{...state,atomValues:state.atomValues.clone(),nonvalidatedAtoms:state.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(state.dirtyAtoms)}}(state);for(const action of actions)applyAction(store,newState,action);return invalidateDownstreams(store,newState),newState})}function queueOrPerformStateUpdate(store,action){if(batchStack.length){const actionsByStore=batchStack[batchStack.length-1];let actions=actionsByStore.get(store);actions||actionsByStore.set(store,actions=[]),actions.push(action)}else applyActionsToStore(store,[action])}const batchStack=[];function invalidateDownstreams(store,state){const downstreams=getDownstreamNodes$1(store,state,state.dirtyAtoms);for(const key of downstreams){var _getNodeMaybe,_getNodeMaybe$invalid;null===(_getNodeMaybe=getNodeMaybe$2(key))||void 0===_getNodeMaybe||null===(_getNodeMaybe$invalid=_getNodeMaybe.invalidate)||void 0===_getNodeMaybe$invalid||_getNodeMaybe$invalid.call(_getNodeMaybe,state)}}function setRecoilValue(store,recoilValue,valueOrUpdater){queueOrPerformStateUpdate(store,{type:"set",recoilValue:recoilValue,valueOrUpdater:valueOrUpdater})}let subscriptionID=0;var Recoil_RecoilValueInterface={RecoilValueReadOnly:RecoilValueReadOnly$1,AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,getRecoilValueAsLoadable:function(store,{key:key},treeState=store.getState().currentTree){var _storeState$nextTree,_storeState$previousT;const storeState=store.getState();treeState.version!==storeState.currentTree.version&&treeState.version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&(treeState.version,null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT||_storeState$previousT.version);const loadable=getNodeLoadable$1(store,treeState,key);return"loading"===loadable.state&&loadable.contents.catch(()=>CANCELED$1),loadable},setRecoilValue:setRecoilValue,setRecoilValueLoadable:function(store,recoilValue,loadable){if(loadable instanceof DefaultValue$1)return setRecoilValue(store,recoilValue,loadable);queueOrPerformStateUpdate(store,{type:"setLoadable",recoilValue:recoilValue,loadable:loadable})},markRecoilValueModified:function(store,recoilValue){queueOrPerformStateUpdate(store,{type:"markModified",recoilValue:recoilValue})},setUnvalidatedRecoilValue:function(store,recoilValue,unvalidatedValue){queueOrPerformStateUpdate(store,{type:"setUnvalidated",recoilValue:recoilValue,unvalidatedValue:unvalidatedValue})},subscribeToRecoilValue:function(store,{key:key},callback,componentDebugName=null){const subID=subscriptionID++,storeState=store.getState();return storeState.nodeToComponentSubscriptions.has(key)||storeState.nodeToComponentSubscriptions.set(key,new Map),Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID,[null!=componentDebugName?componentDebugName:"<not captured>",callback]),{release:()=>{const storeState=store.getState(),subs=storeState.nodeToComponentSubscriptions.get(key);void 0!==subs&&subs.has(subID)&&(subs.delete(subID),0===subs.size&&storeState.nodeToComponentSubscriptions.delete(key))}}},isRecoilValue:isRecoilValue$1,applyAtomValueWrites:function(atomValues,writes){const result=atomValues.clone();return writes.forEach((v,k)=>{"hasValue"===v.state&&v.contents instanceof DefaultValue$1?result.delete(k):result.set(k,v)}),result},batchStart:function(){const actionsByStore=new Map;return batchStack.push(actionsByStore),()=>{for(const[store,actions]of actionsByStore)applyActionsToStore(store,actions);batchStack.pop()}},invalidateDownstreams_FOR_TESTING:invalidateDownstreams};const{unstable_batchedUpdates:unstable_batchedUpdates}=reactDom;var ReactBatchedUpdates={unstable_batchedUpdates:unstable_batchedUpdates};const{unstable_batchedUpdates:unstable_batchedUpdates$1}=ReactBatchedUpdates;var Recoil_ReactBatchedUpdates={unstable_batchedUpdates:unstable_batchedUpdates$1};const{batchStart:batchStart$1}=Recoil_RecoilValueInterface,{unstable_batchedUpdates:unstable_batchedUpdates$2}=Recoil_ReactBatchedUpdates;let batcher=unstable_batchedUpdates$2;var Recoil_Batching={getBatcher:()=>batcher,setBatcher:newBatcher=>{batcher=newBatcher},batchUpdates:callback=>{batcher(()=>{let batchEnd=()=>{};try{batchEnd=batchStart$1(),callback()}finally{batchEnd()}})}};var Recoil_Queue={enqueueExecution:function(s,f){f()}};var Recoil_differenceSets=function(set,...setsWithValuesToRemove){const ret=new Set;FIRST:for(const value of set){for(const otherSet of setsWithValuesToRemove)if(otherSet.has(value))continue FIRST;ret.add(value)}return ret};var Recoil_mapMap=function(map,callback){const result=new Map;return map.forEach((value,key)=>{result.set(key,callback(value,key))}),result};function mergeDependencyMapIntoGraph(deps,graph,olderGraph){const{nodeDeps:nodeDeps,nodeToNodeSubscriptions:nodeToNodeSubscriptions}=graph;deps.forEach((upstreams,downstream)=>{const existingUpstreams=nodeDeps.get(downstream);if(existingUpstreams&&olderGraph&&existingUpstreams!==olderGraph.nodeDeps.get(downstream))return;nodeDeps.set(downstream,new Set(upstreams));if((null==existingUpstreams?upstreams:Recoil_differenceSets(upstreams,existingUpstreams)).forEach(upstream=>{nodeToNodeSubscriptions.has(upstream)||nodeToNodeSubscriptions.set(upstream,new Set);Recoil_nullthrows(nodeToNodeSubscriptions.get(upstream)).add(downstream)}),existingUpstreams){Recoil_differenceSets(existingUpstreams,upstreams).forEach(upstream=>{if(!nodeToNodeSubscriptions.has(upstream))return;const existing=Recoil_nullthrows(nodeToNodeSubscriptions.get(upstream));existing.delete(downstream),0===existing.size&&nodeToNodeSubscriptions.delete(upstream)})}})}var Recoil_Graph={addToDependencyMap:function(downstream,upstream,dependencyMap){dependencyMap.has(downstream)||dependencyMap.set(downstream,new Set),Recoil_nullthrows(dependencyMap.get(downstream)).add(upstream)},cloneGraph:function(graph){return{nodeDeps:Recoil_mapMap(graph.nodeDeps,s=>new Set(s)),nodeToNodeSubscriptions:Recoil_mapMap(graph.nodeToNodeSubscriptions,s=>new Set(s))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(from,into){from.forEach((upstreamDeps,downstreamNode)=>{into.has(downstreamNode)||into.set(downstreamNode,new Set);const deps=Recoil_nullthrows(into.get(downstreamNode));upstreamDeps.forEach(dep=>deps.add(dep))})},saveDependencyMapToStore:function(dependencyMap,store,version){var _storeState$nextTree,_storeState$previousT,_storeState$previousT2,_storeState$previousT3;const storeState=store.getState();version!==storeState.currentTree.version&&version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&(null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT||_storeState$previousT.version);const graph=store.getGraph(version);if(mergeDependencyMapIntoGraph(dependencyMap,graph),version===(null===(_storeState$previousT2=storeState.previousTree)||void 0===_storeState$previousT2?void 0:_storeState$previousT2.version)){mergeDependencyMapIntoGraph(dependencyMap,store.getGraph(storeState.currentTree.version),graph)}if(version===(null===(_storeState$previousT3=storeState.previousTree)||void 0===_storeState$previousT3?void 0:_storeState$previousT3.version)||version===storeState.currentTree.version){var _storeState$nextTree2;const nextVersion=null===(_storeState$nextTree2=storeState.nextTree)||void 0===_storeState$nextTree2?void 0:_storeState$nextTree2.version;if(void 0!==nextVersion){mergeDependencyMapIntoGraph(dependencyMap,store.getGraph(nextVersion),graph)}}}};var hamt_1=function(fn,module){return fn(module={exports:{}},module.exports),module.exports}((function(module){var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},hamt={},BUCKET_SIZE=Math.pow(2,5),MASK=BUCKET_SIZE-1,MAX_INDEX_NODE=BUCKET_SIZE/2,MIN_ARRAY_NODE=BUCKET_SIZE/4,nothing={},constant=function(x){return function(){return x}},hash=hamt.hash=function(str){var type=void 0===str?"undefined":_typeof(str);if("number"===type)return str;"string"!==type&&(str+="");for(var hash=0,i=0,len=str.length;i<len;++i){hash=(hash<<5)-hash+str.charCodeAt(i)|0}return hash},hashFragment=function(shift,h){return h>>>shift&MASK},toBitmap=function(x){return 1<<x},fromBitmap=function(bitmap,bit){return x=bitmap&bit-1,x=(x=(858993459&(x-=x>>1&1431655765))+(x>>2&858993459))+(x>>4)&252645135,x+=x>>8,127&(x+=x>>16);var x},arrayUpdate=function(mutate,at,v,arr){var out=arr;if(!mutate){var len=arr.length;out=new Array(len);for(var i=0;i<len;++i)out[i]=arr[i]}return out[at]=v,out},arraySpliceOut=function(mutate,at,arr){var newLen=arr.length-1,i=0,g=0,out=arr;if(mutate)i=g=at;else for(out=new Array(newLen);i<at;)out[g++]=arr[i++];for(++i;i<=newLen;)out[g++]=arr[i++];return mutate&&(out.length=newLen),out},empty={__hamt_isEmpty:!0},isEmptyNode=function(x){return x===empty||x&&x.__hamt_isEmpty},Leaf=function(edit,hash,key,value){return{type:1,edit:edit,hash:hash,key:key,value:value,_modify:Leaf__modify}},Collision=function(edit,hash,children){return{type:2,edit:edit,hash:hash,children:children,_modify:Collision__modify}},IndexedNode=function(edit,mask,children){return{type:3,edit:edit,mask:mask,children:children,_modify:IndexedNode__modify}},ArrayNode=function(edit,size,children){return{type:4,edit:edit,size:size,children:children,_modify:ArrayNode__modify}},mergeLeaves=function mergeLeaves(edit,shift,h1,n1,h2,n2){if(h1===h2)return Collision(edit,h1,[n2,n1]);var subH1=hashFragment(shift,h1),subH2=hashFragment(shift,h2);return IndexedNode(edit,toBitmap(subH1)|toBitmap(subH2),subH1===subH2?[mergeLeaves(edit,shift+5,h1,n1,h2,n2)]:subH1<subH2?[n1,n2]:[n2,n1])},canEditNode=function(edit,node){return edit===node.edit},Leaf__modify=function(edit,keyEq,shift,f,h,k,size){if(keyEq(k,this.key)){var _v=f(this.value);return _v===this.value?this:_v===nothing?(--size.value,empty):canEditNode(edit,this)?(this.value=_v,this):Leaf(edit,h,k,_v)}var v=f();return v===nothing?this:(++size.value,mergeLeaves(edit,shift,this.hash,this,h,Leaf(edit,h,k,v)))},Collision__modify=function(edit,keyEq,shift,f,h,k,size){if(h===this.hash){var list=function(mutate,edit,keyEq,h,list,f,k,size){for(var len=list.length,i=0;i<len;++i){var child=list[i];if(keyEq(k,child.key)){var value=child.value,_newValue=f(value);return _newValue===value?list:_newValue===nothing?(--size.value,arraySpliceOut(mutate,i,list)):arrayUpdate(mutate,i,Leaf(edit,h,k,_newValue),list)}}var newValue=f();return newValue===nothing?list:(++size.value,arrayUpdate(mutate,len,Leaf(edit,h,k,newValue),list))}(canEditNode(edit,this),edit,keyEq,this.hash,this.children,f,k,size);return list===this.children?this:list.length>1?Collision(edit,this.hash,list):list[0]}var v=f();return v===nothing?this:(++size.value,mergeLeaves(edit,shift,this.hash,this,h,Leaf(edit,h,k,v)))},IndexedNode__modify=function(edit,keyEq,shift,f,h,k,size){var mask=this.mask,children=this.children,frag=hashFragment(shift,h),bit=toBitmap(frag),indx=fromBitmap(mask,bit),exists=mask&bit,current=exists?children[indx]:empty,child=current._modify(edit,keyEq,shift+5,f,h,k,size);if(current===child)return this;var node,canEdit=canEditNode(edit,this),bitmap=mask,newChildren=void 0;if(exists&&isEmptyNode(child)){if(!(bitmap&=~bit))return empty;if(children.length<=2&&((node=children[1^indx])===empty||1===node.type||2===node.type))return children[1^indx];newChildren=arraySpliceOut(canEdit,indx,children)}else if(exists||isEmptyNode(child))newChildren=arrayUpdate(canEdit,indx,child,children);else{if(children.length>=MAX_INDEX_NODE)return function(edit,frag,child,bitmap,subNodes){for(var arr=[],bit=bitmap,count=0,i=0;bit;++i)1&bit&&(arr[i]=subNodes[count++]),bit>>>=1;return arr[frag]=child,ArrayNode(edit,count+1,arr)}(edit,frag,child,mask,children);bitmap|=bit,newChildren=function(mutate,at,v,arr){var len=arr.length;if(mutate){for(var _i=len;_i>=at;)arr[_i--]=arr[_i];return arr[at]=v,arr}for(var i=0,g=0,out=new Array(len+1);i<at;)out[g++]=arr[i++];for(out[at]=v;i<len;)out[++g]=arr[i++];return out}(canEdit,indx,child,children)}return canEdit?(this.mask=bitmap,this.children=newChildren,this):IndexedNode(edit,bitmap,newChildren)},ArrayNode__modify=function(edit,keyEq,shift,f,h,k,size){var count=this.size,children=this.children,frag=hashFragment(shift,h),child=children[frag],newChild=(child||empty)._modify(edit,keyEq,shift+5,f,h,k,size);if(child===newChild)return this;var canEdit=canEditNode(edit,this),newChildren=void 0;if(isEmptyNode(child)&&!isEmptyNode(newChild))++count,newChildren=arrayUpdate(canEdit,frag,newChild,children);else if(!isEmptyNode(child)&&isEmptyNode(newChild)){if(--count<=MIN_ARRAY_NODE)return function(edit,count,removed,elements){for(var children=new Array(count-1),g=0,bitmap=0,i=0,len=elements.length;i<len;++i)if(i!==removed){var elem=elements[i];elem&&!isEmptyNode(elem)&&(children[g++]=elem,bitmap|=1<<i)}return IndexedNode(edit,bitmap,children)}(edit,count,frag,children);newChildren=arrayUpdate(canEdit,frag,empty,children)}else newChildren=arrayUpdate(canEdit,frag,newChild,children);return canEdit?(this.size=count,this.children=newChildren,this):ArrayNode(edit,count,newChildren)};function Map(editable,edit,config,root,size){this._editable=editable,this._edit=edit,this._config=config,this._root=root,this._size=size}empty._modify=function(edit,keyEq,shift,f,h,k,size){var v=f();return v===nothing?empty:(++size.value,Leaf(edit,h,k,v))},Map.prototype.setTree=function(newRoot,newSize){return this._editable?(this._root=newRoot,this._size=newSize,this):newRoot===this._root?this:new Map(this._editable,this._edit,this._config,newRoot,newSize)};var tryGetHash=hamt.tryGetHash=function(alt,hash,key,map){for(var node=map._root,shift=0,keyEq=map._config.keyEq;;)switch(node.type){case 1:return keyEq(key,node.key)?node.value:alt;case 2:if(hash===node.hash)for(var children=node.children,i=0,len=children.length;i<len;++i){var child=children[i];if(keyEq(key,child.key))return child.value}return alt;case 3:var frag=hashFragment(shift,hash),bit=toBitmap(frag);if(node.mask&bit){node=node.children[fromBitmap(node.mask,bit)],shift+=5;break}return alt;case 4:if(node=node.children[hashFragment(shift,hash)]){shift+=5;break}return alt;default:return alt}};Map.prototype.tryGetHash=function(alt,hash,key){return tryGetHash(alt,hash,key,this)};var tryGet=hamt.tryGet=function(alt,key,map){return tryGetHash(alt,map._config.hash(key),key,map)};Map.prototype.tryGet=function(alt,key){return tryGet(alt,key,this)};var getHash=hamt.getHash=function(hash,key,map){return tryGetHash(void 0,hash,key,map)};Map.prototype.getHash=function(hash,key){return getHash(hash,key,this)};hamt.get=function(key,map){return tryGetHash(void 0,map._config.hash(key),key,map)};Map.prototype.get=function(key,alt){return tryGet(alt,key,this)};var hasHash=hamt.has=function(hash,key,map){return tryGetHash(nothing,hash,key,map)!==nothing};Map.prototype.hasHash=function(hash,key){return hasHash(hash,key,this)};var has=hamt.has=function(key,map){return hasHash(map._config.hash(key),key,map)};Map.prototype.has=function(key){return has(key,this)};var defKeyCompare=function(x,y){return x===y};hamt.make=function(config){return new Map(0,0,{keyEq:config&&config.keyEq||defKeyCompare,hash:config&&config.hash||hash},empty,0)},hamt.empty=hamt.make();var isEmpty=hamt.isEmpty=function(map){return map&&!!isEmptyNode(map._root)};Map.prototype.isEmpty=function(){return isEmpty(this)};var modifyHash=hamt.modifyHash=function(f,hash,key,map){var size={value:map._size},newRoot=map._root._modify(map._editable?map._edit:NaN,map._config.keyEq,0,f,hash,key,size);return map.setTree(newRoot,size.value)};Map.prototype.modifyHash=function(hash,key,f){return modifyHash(f,hash,key,this)};var modify=hamt.modify=function(f,key,map){return modifyHash(f,map._config.hash(key),key,map)};Map.prototype.modify=function(key,f){return modify(f,key,this)};var setHash=hamt.setHash=function(hash,key,value,map){return modifyHash(constant(value),hash,key,map)};Map.prototype.setHash=function(hash,key,value){return setHash(hash,key,value,this)};var set=hamt.set=function(key,value,map){return setHash(map._config.hash(key),key,value,map)};Map.prototype.set=function(key,value){return set(key,value,this)};var del=constant(nothing),removeHash=hamt.removeHash=function(hash,key,map){return modifyHash(del,hash,key,map)};Map.prototype.removeHash=Map.prototype.deleteHash=function(hash,key){return removeHash(hash,key,this)};var remove=hamt.remove=function(key,map){return removeHash(map._config.hash(key),key,map)};Map.prototype.remove=Map.prototype.delete=function(key){return remove(key,this)};var beginMutation=hamt.beginMutation=function(map){return new Map(map._editable+1,map._edit+1,map._config,map._root,map._size)};Map.prototype.beginMutation=function(){return beginMutation(this)};var endMutation=hamt.endMutation=function(map){return map._editable=map._editable&&map._editable-1,map};Map.prototype.endMutation=function(){return endMutation(this)};var mutate=hamt.mutate=function(f,map){var transient=beginMutation(map);return f(transient),endMutation(transient)};Map.prototype.mutate=function(f){return mutate(f,this)};var appk=function(k){return k&&lazyVisitChildren(k[0],k[1],k[2],k[3],k[4])},lazyVisitChildren=function(len,children,i,f,k){for(;i<len;){var child=children[i++];if(child&&!isEmptyNode(child))return lazyVisit(child,f,[len,children,i,f,k])}return appk(k)},lazyVisit=function(node,f,k){switch(node.type){case 1:return{value:f(node),rest:k};case 2:case 4:case 3:var children=node.children;return lazyVisitChildren(children.length,children,0,f,k);default:return appk(k)}},DONE={done:!0};function MapIterator(v){this.v=v}MapIterator.prototype.next=function(){if(!this.v)return DONE;var v0=this.v;return this.v=appk(v0.rest),v0},MapIterator.prototype[Symbol.iterator]=function(){return this};var visit=function(map,f){return new MapIterator(lazyVisit(map._root,f))},buildPairs=function(x){return[x.key,x.value]},entries=hamt.entries=function(map){return visit(map,buildPairs)};Map.prototype.entries=Map.prototype[Symbol.iterator]=function(){return entries(this)};var buildKeys=function(x){return x.key},keys=hamt.keys=function(map){return visit(map,buildKeys)};Map.prototype.keys=function(){return keys(this)};var buildValues=function(x){return x.value},values=hamt.values=Map.prototype.values=function(map){return visit(map,buildValues)};Map.prototype.values=function(){return values(this)};var fold=hamt.fold=function(f,z,m){var root=m._root;if(1===root.type)return f(z,root.value,root.key);for(var toVisit=[root.children],children=void 0;children=toVisit.pop();)for(var i=0,len=children.length;i<len;){var child=children[i++];child&&child.type&&(1===child.type?z=f(z,child.value,child.key):toVisit.push(child.children))}return z};Map.prototype.fold=function(f,z){return fold(f,z,this)};var forEach=hamt.forEach=function(f,map){return fold((function(_,value,key){return f(value,key,map)}),null,map)};Map.prototype.forEach=function(f){return forEach(f,this)};var count=hamt.count=function(map){return map._size};Map.prototype.count=function(){return count(this)},Object.defineProperty(Map.prototype,"size",{get:Map.prototype.count}),module.exports?module.exports=hamt:(void 0).hamt=hamt}));class BuiltInMap{constructor(existing){_defineProperty(this,"_map",void 0),this._map=new Map(null==existing?void 0:existing.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(k){return this._map.get(k)}has(k){return this._map.has(k)}set(k,v){return this._map.set(k,v),this}delete(k){return this._map.delete(k),this}clone(){return persistentMap(this)}toMap(){return new Map(this._map)}}class HashArrayMappedTrieMap{constructor(existing){if(_defineProperty(this,"_hamt",hamt_1.empty.beginMutation()),existing instanceof HashArrayMappedTrieMap){const h=existing._hamt.endMutation();existing._hamt=h.beginMutation(),this._hamt=h.beginMutation()}else if(existing)for(const[k,v]of existing.entries())this._hamt.set(k,v)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(k){return this._hamt.get(k)}has(k){return this._hamt.has(k)}set(k,v){return this._hamt.set(k,v),this}delete(k){return this._hamt.delete(k),this}clone(){return persistentMap(this)}toMap(){return new Map(this._hamt)}}function persistentMap(existing){return Recoil_gkx_1("recoil_hamt_2020")?new HashArrayMappedTrieMap(existing):new BuiltInMap(existing)}var Recoil_PersistentMap_1=persistentMap,Recoil_PersistentMap$1=Object.freeze({__proto__:null,persistentMap:Recoil_PersistentMap_1});const{graph:graph$1}=Recoil_Graph,{persistentMap:persistentMap$1}=Recoil_PersistentMap$1;let nextTreeStateVersion=0;const getNextTreeStateVersion=()=>nextTreeStateVersion++;function makeEmptyTreeState(){const version=getNextTreeStateVersion();return{version:version,stateID:version,transactionMetadata:{},dirtyAtoms:new Set,atomValues:persistentMap$1(),nonvalidatedAtoms:persistentMap$1()}}var Recoil_State={makeEmptyTreeState:makeEmptyTreeState,makeEmptyStoreState:function(){const currentTree=makeEmptyTreeState();return{currentTree:currentTree,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(currentTree.version,graph$1()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:getNextTreeStateVersion};var Recoil_unionSets=function(...sets){const result=new Set;for(const set of sets)for(const value of set)result.add(value);return result};var Recoil_someSet=function(set,callback,context){const iterator=set.entries();let current=iterator.next();for(;!current.done;){const entry=current.value;if(callback.call(context,entry[1],entry[0],set))return!0;current=iterator.next()}return!1};const{cleanUpNode:cleanUpNode$1}=Recoil_FunctionalCore,{deleteNodeConfigIfPossible:deleteNodeConfigIfPossible$1,getNode:getNode$2}=Recoil_Node,{RetentionZone:RetentionZone$2}=Recoil_RetentionZone,emptySet$1=new Set;function releaseRetainablesNowOnCurrentTree(store,retainables){const storeState=store.getState(),treeState=storeState.currentTree;if(storeState.nextTree)return;const nodes=new Set;for(const r of retainables)if(r instanceof RetentionZone$2)for(const n of nodesRetainedByZone(storeState,r))nodes.add(n);else nodes.add(r);const releasableNodes=function(store,searchFromNodes){const storeState=store.getState(),treeState=storeState.currentTree,graph=store.getGraph(treeState.version),releasableNodes=new Set,nonReleasableNodes=new Set;return findReleasableNodesInner(searchFromNodes),releasableNodes;function findReleasableNodesInner(searchFromNodes){const releasableNodesFoundThisIteration=new Set,downstreams=function(store,treeState,nodes,doNotDescendInto1,doNotDescendInto2){const graph=store.getGraph(treeState.version),answer=[],visited=new Set;for(;nodes.size>0;)visit(Recoil_nullthrows(nodes.values().next().value));return answer;function visit(node){if(doNotDescendInto1.has(node)||doNotDescendInto2.has(node))return void nodes.delete(node);if(visited.has(node))return;const children=graph.nodeToNodeSubscriptions.get(node);if(children)for(const child of children)visit(child);visited.add(node),nodes.delete(node),answer.push(node)}}(store,treeState,searchFromNodes,releasableNodes,nonReleasableNodes);for(const node of downstreams){var _storeState$retention;if("recoilRoot"===getNode$2(node).retainedBy){nonReleasableNodes.add(node);continue}if((null!==(_storeState$retention=storeState.retention.referenceCounts.get(node))&&void 0!==_storeState$retention?_storeState$retention:0)>0){nonReleasableNodes.add(node);continue}if(zonesThatCouldRetainNode(node).some(z=>storeState.retention.referenceCounts.get(z))){nonReleasableNodes.add(node);continue}const nodeChildren=graph.nodeToNodeSubscriptions.get(node);nodeChildren&&Recoil_someSet(nodeChildren,child=>nonReleasableNodes.has(child))?nonReleasableNodes.add(node):(releasableNodes.add(node),releasableNodesFoundThisIteration.add(node))}const parents=new Set;for(const node of releasableNodesFoundThisIteration)for(const parent of null!==(_graph$nodeDeps$get=graph.nodeDeps.get(node))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:emptySet$1){var _graph$nodeDeps$get;releasableNodes.has(parent)||parents.add(parent)}parents.size&&findReleasableNodesInner(parents)}}(store,nodes);for(const node of releasableNodes)releaseNode(store,treeState,node)}function releaseNode(store,treeState,node){if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;cleanUpNode$1(store,node);const storeState=store.getState();storeState.knownAtoms.delete(node),storeState.knownSelectors.delete(node),storeState.nodeTransactionSubscriptions.delete(node),storeState.retention.referenceCounts.delete(node);const zones=zonesThatCouldRetainNode(node);for(const zone of zones){var _storeState$retention2;null===(_storeState$retention2=storeState.retention.nodesRetainedByZone.get(zone))||void 0===_storeState$retention2||_storeState$retention2.delete(node)}treeState.atomValues.delete(node),treeState.dirtyAtoms.delete(node),treeState.nonvalidatedAtoms.delete(node);const graph=storeState.graphsByVersion.get(treeState.version);if(graph){const deps=graph.nodeDeps.get(node);if(void 0!==deps){graph.nodeDeps.delete(node);for(const dep of deps){var _graph$nodeToNodeSubs;null===(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(dep))||void 0===_graph$nodeToNodeSubs||_graph$nodeToNodeSubs.delete(node)}}graph.nodeToNodeSubscriptions.delete(node)}deleteNodeConfigIfPossible$1(node)}function nodesRetainedByZone(storeState,zone){var _storeState$retention3;return null!==(_storeState$retention3=storeState.retention.nodesRetainedByZone.get(zone))&&void 0!==_storeState$retention3?_storeState$retention3:emptySet$1}function zonesThatCouldRetainNode(node){const retainedBy=getNode$2(node).retainedBy;return void 0===retainedBy||"components"===retainedBy||"recoilRoot"===retainedBy?[]:retainedBy instanceof RetentionZone$2?[retainedBy]:retainedBy}function updateRetainCountToZero(store,retainable){if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;store.getState().retention.referenceCounts.delete(retainable),function(store,retainable){const state=store.getState();state.nextTree?state.retention.retainablesToCheckForRelease.add(retainable):releaseRetainablesNowOnCurrentTree(store,new Set([retainable]))}(store,retainable)}var Recoil_Retention={updateRetainCount:function(store,retainable,delta){var _map$get;if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;const map=store.getState().retention.referenceCounts,newCount=(null!==(_map$get=map.get(retainable))&&void 0!==_map$get?_map$get:0)+delta;0===newCount?updateRetainCountToZero(store,retainable):map.set(retainable,newCount)},updateRetainCountToZero:updateRetainCountToZero,releaseScheduledRetainablesNow:function(store){if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;const state=store.getState();releaseRetainablesNowOnCurrentTree(store,state.retention.retainablesToCheckForRelease),state.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(r){return void 0===r?"recoilRoot":r}};var Recoil_concatIterables=function*(iters){for(const iter of iters)for(const val of iter)yield val};var Recoil_Environment={isSSR:"undefined"==typeof window,isReactNative:"undefined"!=typeof navigator&&"ReactNative"===navigator.product};const{isSSR:isSSR$1}=Recoil_Environment,{batchUpdates:batchUpdates$1}=Recoil_Batching,{initializeNodeIfNewToStore:initializeNodeIfNewToStore$1,peekNodeInfo:peekNodeInfo$1}=Recoil_FunctionalCore,{graph:graph$2}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$1,recoilValues:recoilValues$1,recoilValuesForKeys:recoilValuesForKeys$2}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$2,getRecoilValueAsLoadable:getRecoilValueAsLoadable$1,setRecoilValue:setRecoilValue$1,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$1}=Recoil_RecoilValueInterface,{updateRetainCount:updateRetainCount$1,updateRetainCountToZero:updateRetainCountToZero$1}=Recoil_Retention,{getNextTreeStateVersion:getNextTreeStateVersion$1,makeEmptyStoreState:makeEmptyStoreState$1}=Recoil_State;class Snapshot{constructor(storeState){_defineProperty(this,"_store",void 0),_defineProperty(this,"_refCount",0),_defineProperty(this,"getLoadable",recoilValue=>(this.checkRefCount_INTERNAL(),getRecoilValueAsLoadable$1(this._store,recoilValue))),_defineProperty(this,"getPromise",recoilValue=>(this.checkRefCount_INTERNAL(),this.getLoadable(recoilValue).toPromise())),_defineProperty(this,"getNodes_UNSTABLE",opt=>{if(this.checkRefCount_INTERNAL(),!0===(null==opt?void 0:opt.isModified)){if(!1===(null==opt?void 0:opt.isInitialized))return[];const state=this._store.getState().currentTree;return recoilValuesForKeys$2(state.dirtyAtoms)}const knownAtoms=this._store.getState().knownAtoms,knownSelectors=this._store.getState().knownSelectors;return null==(null==opt?void 0:opt.isInitialized)?recoilValues$1.values():!0===opt.isInitialized?recoilValuesForKeys$2(Recoil_concatIterables([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):Recoil_filterIterable(recoilValues$1.values(),({key:key})=>!knownAtoms.has(key)&&!knownSelectors.has(key))}),_defineProperty(this,"getInfo_UNSTABLE",({key:key})=>(this.checkRefCount_INTERNAL(),peekNodeInfo$1(this._store,this._store.getState().currentTree,key))),_defineProperty(this,"map",mapper=>{this.checkRefCount_INTERNAL();const mutableSnapshot=new MutableSnapshot(this);return mapper(mutableSnapshot),cloneSnapshot(mutableSnapshot.getStore_INTERNAL())}),_defineProperty(this,"asyncMap",async mapper=>{this.checkRefCount_INTERNAL();const mutableSnapshot=new MutableSnapshot(this);return await mapper(mutableSnapshot),cloneSnapshot(mutableSnapshot.getStore_INTERNAL())}),this._store={getState:()=>storeState,replaceState:replacer=>{storeState.currentTree=replacer(storeState.currentTree)},getGraph:version=>{const graphs=storeState.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$2();return graphs.set(version,newGraph),newGraph},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}};for(const nodeKey of this._store.getState().nodeCleanupFunctions.keys())initializeNodeIfNewToStore$1(this._store,storeState.currentTree,nodeKey,"get"),updateRetainCount$1(this._store,nodeKey,1);this.retain(),this.autorelease_INTERNAL()}retain(){if(!Recoil_gkx_1("recoil_memory_managament_2020"))return()=>{};this._refCount++;let released=!1;return()=>{released||(released=!0,this.release_INTERNAL())}}autorelease_INTERNAL(){Recoil_gkx_1("recoil_memory_managament_2020")&&(isSSR$1||window.setTimeout(()=>this.release_INTERNAL(),0))}release_INTERNAL(){Recoil_gkx_1("recoil_memory_managament_2020")&&(this._refCount--,this._refCount)}checkRefCount_INTERNAL(){Recoil_gkx_1("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function cloneStoreState(store,treeState,bumpVersion=!1){const storeState=store.getState(),version=bumpVersion?getNextTreeStateVersion$1():treeState.version;return{currentTree:bumpVersion?{version:version,stateID:version,transactionMetadata:{...treeState.transactionMetadata},dirtyAtoms:new Set(treeState.dirtyAtoms),atomValues:treeState.atomValues.clone(),nonvalidatedAtoms:treeState.nonvalidatedAtoms.clone()}:treeState,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(storeState.knownAtoms),knownSelectors:new Set(storeState.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(version,store.getGraph(treeState.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function cloneSnapshot(store,version="current"){const storeState=store.getState(),treeState="current"===version?storeState.currentTree:Recoil_nullthrows(storeState.previousTree);return new Snapshot(cloneStoreState(store,treeState))}class MutableSnapshot extends Snapshot{constructor(snapshot){super(cloneStoreState(snapshot.getStore_INTERNAL(),snapshot.getStore_INTERNAL().getState().currentTree,!0)),_defineProperty(this,"set",(recoilState,newValueOrUpdater)=>{this.checkRefCount_INTERNAL();const store=this.getStore_INTERNAL();batchUpdates$1(()=>{updateRetainCount$1(store,recoilState.key,1),setRecoilValue$1(this.getStore_INTERNAL(),recoilState,newValueOrUpdater)})}),_defineProperty(this,"reset",recoilState=>{this.checkRefCount_INTERNAL();const store=this.getStore_INTERNAL();batchUpdates$1(()=>{updateRetainCount$1(store,recoilState.key,1),setRecoilValue$1(this.getStore_INTERNAL(),recoilState,DEFAULT_VALUE$1)})}),_defineProperty(this,"setUnvalidatedAtomValues_DEPRECATED",values=>{this.checkRefCount_INTERNAL();const store=this.getStore_INTERNAL();batchUpdates$1(()=>{for(const[k,v]of values.entries())updateRetainCount$1(store,k,1),setUnvalidatedRecoilValue$1(store,new AbstractRecoilValue$2(k),v)})})}}var Recoil_Snapshot={Snapshot:Snapshot,MutableSnapshot:MutableSnapshot,freshSnapshot:function(initializeState){const snapshot=new Snapshot(makeEmptyStoreState$1());return null!=initializeState?snapshot.map(initializeState):snapshot},cloneSnapshot:cloneSnapshot},Recoil_Snapshot_1=Recoil_Snapshot.Snapshot,Recoil_Snapshot_2=Recoil_Snapshot.MutableSnapshot,Recoil_Snapshot_3=Recoil_Snapshot.freshSnapshot,Recoil_Snapshot_4=Recoil_Snapshot.cloneSnapshot,Recoil_Snapshot$1=Object.freeze({__proto__:null,Snapshot:Recoil_Snapshot_1,MutableSnapshot:Recoil_Snapshot_2,freshSnapshot:Recoil_Snapshot_3,cloneSnapshot:Recoil_Snapshot_4});const{getNextTreeStateVersion:getNextTreeStateVersion$2,makeEmptyStoreState:makeEmptyStoreState$2}=Recoil_State,{cleanUpNode:cleanUpNode$2,getDownstreamNodes:getDownstreamNodes$2,setNodeValue:setNodeValue$2,setUnvalidatedAtomValue_DEPRECATED:setUnvalidatedAtomValue_DEPRECATED$1}=Recoil_FunctionalCore,{graph:graph$3}=Recoil_Graph,{cloneGraph:cloneGraph$1}=Recoil_Graph,{applyAtomValueWrites:applyAtomValueWrites$1}=Recoil_RecoilValueInterface,{releaseScheduledRetainablesNow:releaseScheduledRetainablesNow$1}=Recoil_Retention,{freshSnapshot:freshSnapshot$1}=Recoil_Snapshot$1,{useCallback:useCallback,useContext:useContext,useEffect:useEffect,useMemo:useMemo,useRef:useRef,useState:useState}=react;function notInAContext(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const defaultStore=Object.freeze({getState:notInAContext,replaceState:notInAContext,getGraph:notInAContext,subscribeToTransactions:notInAContext,addTransactionMetadata:notInAContext});let stateReplacerIsBeingExecuted=!1;function startNextTreeIfNeeded(store){if(stateReplacerIsBeingExecuted)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const storeState=store.getState();if(null===storeState.nextTree){Recoil_gkx_1("recoil_memory_managament_2020")&&Recoil_gkx_1("recoil_release_on_cascading_update_killswitch_2021")&&storeState.commitDepth>0&&releaseScheduledRetainablesNow$1(store);const version=storeState.currentTree.version,nextVersion=getNextTreeStateVersion$2();storeState.nextTree={...storeState.currentTree,version:nextVersion,stateID:nextVersion,dirtyAtoms:new Set,transactionMetadata:{}},storeState.graphsByVersion.set(nextVersion,cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))))}}const AppContext=react.createContext({current:defaultStore}),useStoreRef=()=>useContext(AppContext),MutableSourceContext=react.createContext(null);function sendEndOfBatchNotifications(store){const storeState=store.getState(),treeState=storeState.currentTree,dirtyAtoms=treeState.dirtyAtoms;if(dirtyAtoms.size){for(const[key,subscriptions]of storeState.nodeTransactionSubscriptions)if(dirtyAtoms.has(key))for(const[_,subscription]of subscriptions)subscription(store);for(const[_,subscription]of storeState.transactionSubscriptions)subscription(store);const dependentNodes=getDownstreamNodes$2(store,treeState,dirtyAtoms);for(const key of dependentNodes){const comps=storeState.nodeToComponentSubscriptions.get(key);if(comps)for(const[_subID,[_debugName,callback]]of comps)callback(treeState)}storeState.suspendedComponentResolvers.forEach(cb=>cb())}storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb=>cb(treeState)),storeState.queuedComponentCallbacks_DEPRECATED.splice(0,storeState.queuedComponentCallbacks_DEPRECATED.length)}function Batcher({setNotifyBatcherOfChange:setNotifyBatcherOfChange}){const storeRef=useStoreRef(),[_,setState]=useState([]);return setNotifyBatcherOfChange(()=>setState({})),useEffect(()=>{Recoil_Queue.enqueueExecution("Batcher",()=>{const storeState=storeRef.current.getState();storeState.commitDepth++;try{const{nextTree:nextTree}=storeState;if(null===nextTree)return;storeState.previousTree=storeState.currentTree,storeState.currentTree=nextTree,storeState.nextTree=null,sendEndOfBatchNotifications(storeRef.current);const discardedVersion=Recoil_nullthrows(storeState.previousTree).version;storeState.graphsByVersion.delete(discardedVersion),storeState.previousTree=null,Recoil_gkx_1("recoil_memory_managament_2020")&&releaseScheduledRetainablesNow$1(storeRef.current)}finally{storeState.commitDepth--}})}),useEffect(()=>()=>{setNotifyBatcherOfChange(()=>{})},[setNotifyBatcherOfChange]),null}let nextID=0;function RecoilRoot_INTERNAL({initializeState_DEPRECATED:initializeState_DEPRECATED,initializeState:initializeState,store_INTERNAL:storeProp,children:children}){var _createMutableSource;let storeState;const notifyBatcherOfChange=useRef(null),setNotifyBatcherOfChange=useCallback(x=>{notifyBatcherOfChange.current=x},[notifyBatcherOfChange]),createMutableSource=null!==(_createMutableSource=react.createMutableSource)&&void 0!==_createMutableSource?_createMutableSource:react.unstable_createMutableSource,store=null!=storeProp?storeProp:{getState:()=>storeState.current,replaceState:replacer=>{const storeState=storeRef.current.getState();startNextTreeIfNeeded(storeRef.current);const nextTree=Recoil_nullthrows(storeState.nextTree);let replaced;try{stateReplacerIsBeingExecuted=!0,replaced=replacer(nextTree)}finally{stateReplacerIsBeingExecuted=!1}replaced!==nextTree&&(storeState.nextTree=replaced,Recoil_nullthrows(notifyBatcherOfChange.current)())},getGraph:version=>{const graphs=storeState.current.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$3();return graphs.set(version,newGraph),newGraph},subscribeToTransactions:(callback,key)=>{if(null==key){const{transactionSubscriptions:transactionSubscriptions}=storeRef.current.getState(),id=nextID++;return transactionSubscriptions.set(id,callback),{release:()=>{transactionSubscriptions.delete(id)}}}{const{nodeTransactionSubscriptions:nodeTransactionSubscriptions}=storeRef.current.getState();nodeTransactionSubscriptions.has(key)||nodeTransactionSubscriptions.set(key,new Map);const id=nextID++;return Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id,callback),{release:()=>{const subs=nodeTransactionSubscriptions.get(key);subs&&(subs.delete(id),0===subs.size&&nodeTransactionSubscriptions.delete(key))}}}},addTransactionMetadata:metadata=>{startNextTreeIfNeeded(storeRef.current);for(const k of Object.keys(metadata))Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k]=metadata[k]}},storeRef=useRef(store);storeState=useRef(null!=initializeState_DEPRECATED?function(store,initializeState){const initial=makeEmptyStoreState$2();return initializeState({set:(atom,value)=>{const state=initial.currentTree,writes=setNodeValue$2(store,state,atom.key,value),writtenNodes=new Set(writes.keys()),nonvalidatedAtoms=state.nonvalidatedAtoms.clone();for(const n of writtenNodes)nonvalidatedAtoms.delete(n);initial.currentTree={...state,dirtyAtoms:Recoil_unionSets(state.dirtyAtoms,writtenNodes),atomValues:applyAtomValueWrites$1(state.atomValues,writes),nonvalidatedAtoms:nonvalidatedAtoms}},setUnvalidatedAtomValues:atomValues=>{atomValues.forEach((v,k)=>{initial.currentTree=setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree,k,v)})}}),initial}(store,initializeState_DEPRECATED):null!=initializeState?function(initializeState){return freshSnapshot$1().map(initializeState).getStore_INTERNAL().getState()}(initializeState):makeEmptyStoreState$2());const mutableSource=useMemo(()=>createMutableSource?createMutableSource(storeState,()=>storeState.current.currentTree.version):null,[createMutableSource,storeState]);return useEffect(()=>()=>{for(const atomKey of storeRef.current.getState().knownAtoms)cleanUpNode$2(storeRef.current,atomKey)},[]),react.createElement(AppContext.Provider,{value:storeRef},react.createElement(MutableSourceContext.Provider,{value:mutableSource},react.createElement(Batcher,{setNotifyBatcherOfChange:setNotifyBatcherOfChange}),children))}var Recoil_RecoilRoot_react={useStoreRef:useStoreRef,useRecoilMutableSource:function(){return useContext(MutableSourceContext)},RecoilRoot:function(props){const{override:override,...propsExceptOverride}=props,ancestorStoreRef=useStoreRef();return!1===override&&ancestorStoreRef.current!==defaultStore?react.createElement(react.Fragment,null,props.children):react.createElement(RecoilRoot_INTERNAL,propsExceptOverride)},sendEndOfBatchNotifications_FOR_TESTING:sendEndOfBatchNotifications};var Recoil_filterMap=function(map,callback){const result=new Map;for(const[key,value]of map)callback(value,key)&&result.set(key,value);return result};var Recoil_filterSet=function(set,callback){const result=new Set;for(const value of set)callback(value)&&result.add(value);return result};var Recoil_invariant=function(condition,message){if(!condition)throw new Error(message)};var _useMutableSource,Recoil_mergeMaps=function(...maps){const result=new Map;for(let i=0;i<maps.length;i++){const iterator=maps[i].keys();let nextKey;for(;!(nextKey=iterator.next()).done;)result.set(nextKey.value,maps[i].get(nextKey.value))}return result};const useMutableSource=null!==(_useMutableSource=react.useMutableSource)&&void 0!==_useMutableSource?_useMutableSource:react.unstable_useMutableSource;var Recoil_mutableSource={mutableSourceExists:function(){return useMutableSource&&!("undefined"!=typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:useMutableSource};var Recoil_shallowArrayEqual=function(a,b){if(a===b)return!0;if(a.length!==b.length)return!1;for(let i=0,l=a.length;i<l;i++)if(a[i]!==b[i])return!1;return!0};const{useRef:useRef$1}=react;var Recoil_useComponentName=function(){return useRef$1(),"<component name not available>"};const{batchUpdates:batchUpdates$2}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$2,getNode:getNode$3,nodes:nodes$1}=Recoil_Node,{useRecoilMutableSource:useRecoilMutableSource$1,useStoreRef:useStoreRef$1}=Recoil_RecoilRoot_react,{AbstractRecoilValue:AbstractRecoilValue$3,getRecoilValueAsLoadable:getRecoilValueAsLoadable$2,setRecoilValue:setRecoilValue$2,setRecoilValueLoadable:setRecoilValueLoadable$1,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$2,subscribeToRecoilValue:subscribeToRecoilValue$1}=Recoil_RecoilValueInterface,{updateRetainCount:updateRetainCount$2}=Recoil_Retention,{RetentionZone:RetentionZone$3}=Recoil_RetentionZone,{Snapshot:Snapshot$1,cloneSnapshot:cloneSnapshot$1}=Recoil_Snapshot$1,{setByAddingToSet:setByAddingToSet$2}=Recoil_CopyOnWrite,{isSSR:isSSR$2}=Recoil_Environment,{mutableSourceExists:mutableSourceExists$1,useMutableSource:useMutableSource$1}=Recoil_mutableSource,{useCallback:useCallback$1,useEffect:useEffect$1,useMemo:useMemo$1,useRef:useRef$2,useState:useState$1}=react;function handleLoadable(loadable,atom,storeRef){if("hasValue"===loadable.state)return loadable.contents;if("loading"===loadable.state){throw new Promise(resolve=>{storeRef.current.getState().suspendedComponentResolvers.add(resolve)})}throw"hasError"===loadable.state?loadable.contents:new Error(`Invalid value of loadable atom "${atom.key}"`)}function useRecoilValueLoadable(recoilValue){return Recoil_gkx_1("recoil_memory_managament_2020")&&useRetain(recoilValue),mutableSourceExists$1()?function(recoilValue){const storeRef=useStoreRef$1(),getLoadable=useCallback$1(()=>{const store=storeRef.current,treeState=store.getState().currentTree;return getRecoilValueAsLoadable$2(store,recoilValue,treeState)},[storeRef,recoilValue]),getLoadableWithTesting=useCallback$1(()=>getLoadable(),[getLoadable]),componentName=Recoil_useComponentName(),subscribe=useCallback$1((_storeState,callback)=>{const store=storeRef.current;return subscribeToRecoilValue$1(store,recoilValue,()=>{if(!Recoil_gkx_1("recoil_suppress_rerender_in_callback"))return callback();const newLoadable=getLoadable();prevLoadableRef.current.is(newLoadable)||callback(),prevLoadableRef.current=newLoadable},componentName).release},[storeRef,recoilValue,componentName,getLoadable]),source=useRecoilMutableSource$1(),loadable=useMutableSource$1(source,getLoadableWithTesting,subscribe),prevLoadableRef=useRef$2(loadable);return useEffect$1(()=>{prevLoadableRef.current=loadable}),loadable}(recoilValue):function(recoilValue){const storeRef=useStoreRef$1(),[_,forceUpdate]=useState$1([]),componentName=Recoil_useComponentName();useEffect$1(()=>{const store=storeRef.current,storeState=store.getState(),subscription=subscribeToRecoilValue$1(store,recoilValue,_state=>{var _prevLoadableRef$curr;if(!Recoil_gkx_1("recoil_suppress_rerender_in_callback"))return forceUpdate([]);const newLoadable=getRecoilValueAsLoadable$2(store,recoilValue,store.getState().currentTree);(null===(_prevLoadableRef$curr=prevLoadableRef.current)||void 0===_prevLoadableRef$curr?void 0:_prevLoadableRef$curr.is(newLoadable))||forceUpdate(newLoadable),prevLoadableRef.current=newLoadable},componentName);if(storeState.nextTree)store.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{prevLoadableRef.current=null,forceUpdate([])});else{var _prevLoadableRef$curr2;if(!Recoil_gkx_1("recoil_suppress_rerender_in_callback"))return forceUpdate([]);const newLoadable=getRecoilValueAsLoadable$2(store,recoilValue,store.getState().currentTree);(null===(_prevLoadableRef$curr2=prevLoadableRef.current)||void 0===_prevLoadableRef$curr2?void 0:_prevLoadableRef$curr2.is(newLoadable))||forceUpdate(newLoadable),prevLoadableRef.current=newLoadable}return subscription.release},[componentName,recoilValue,storeRef]);const loadable=getRecoilValueAsLoadable$2(storeRef.current,recoilValue),prevLoadableRef=useRef$2(loadable);return useEffect$1(()=>{prevLoadableRef.current=loadable}),loadable}(recoilValue)}function useRecoilValue(recoilValue){const storeRef=useStoreRef$1();return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}function useSetRecoilState(recoilState){const storeRef=useStoreRef$1();return useCallback$1(newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)},[storeRef,recoilState])}function useTransactionSubscription(callback){const storeRef=useStoreRef$1();useEffect$1(()=>storeRef.current.subscribeToTransactions(callback).release,[callback,storeRef])}function externallyVisibleAtomValuesInState(state){const atomValues=state.atomValues.toMap(),persistedAtomContentsValues=Recoil_mapMap(Recoil_filterMap(atomValues,(v,k)=>{const persistence=getNode$3(k).persistence_UNSTABLE;return null!=persistence&&"none"!==persistence.type&&"hasValue"===v.state}),v=>v.contents);return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(),persistedAtomContentsValues)}function usePrevious(value){const ref=useRef$2();return useEffect$1(()=>{ref.current=value}),ref.current}function useGotoRecoilSnapshot(){const storeRef=useStoreRef$1();return useCallback$1(snapshot=>{var _storeState$nextTree;const storeState=storeRef.current.getState(),prev=null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree,next=snapshot.getStore_INTERNAL().getState().currentTree;batchUpdates$2(()=>{const keysToUpdate=new Set;for(const keys of[prev.atomValues.keys(),next.atomValues.keys()])for(const key of keys){var _prev$atomValues$get,_next$atomValues$get;(null===(_prev$atomValues$get=prev.atomValues.get(key))||void 0===_prev$atomValues$get?void 0:_prev$atomValues$get.contents)!==(null===(_next$atomValues$get=next.atomValues.get(key))||void 0===_next$atomValues$get?void 0:_next$atomValues$get.contents)&&getNode$3(key).shouldRestoreFromSnapshots&&keysToUpdate.add(key)}keysToUpdate.forEach(key=>{setRecoilValueLoadable$1(storeRef.current,new AbstractRecoilValue$3(key),next.atomValues.has(key)?Recoil_nullthrows(next.atomValues.get(key)):DEFAULT_VALUE$2)}),storeRef.current.replaceState(state=>({...state,stateID:snapshot.getID_INTERNAL()}))})},[storeRef])}class Sentinel{}const SENTINEL=new Sentinel;function useRetain(toRetain){if(Recoil_gkx_1("recoil_memory_managament_2020"))return function(toRetain){const retainables=(Array.isArray(toRetain)?toRetain:[toRetain]).map(a=>a instanceof RetentionZone$3?a:a.key),storeRef=useStoreRef$1();useEffect$1(()=>{if(!Recoil_gkx_1("recoil_memory_managament_2020"))return;const store=storeRef.current;if(timeoutID.current&&!isSSR$2)window.clearTimeout(timeoutID.current),timeoutID.current=null;else for(const r of retainables)updateRetainCount$2(store,r,1);return()=>{for(const r of retainables)updateRetainCount$2(store,r,-1)}},[storeRef,...retainables]);const timeoutID=useRef$2(),previousRetainables=usePrevious(retainables);if(!(isSSR$2||void 0!==previousRetainables&&Recoil_shallowArrayEqual(previousRetainables,retainables))){const store=storeRef.current;for(const r of retainables)updateRetainCount$2(store,r,1);if(previousRetainables)for(const r of previousRetainables)updateRetainCount$2(store,r,-1);timeoutID.current&&window.clearTimeout(timeoutID.current),timeoutID.current=window.setTimeout(()=>{timeoutID.current=null;for(const r of retainables)updateRetainCount$2(store,r,-1)},12e4)}}(toRetain)}var Recoil_Hooks={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useGotoRecoilSnapshot:useGotoRecoilSnapshot,useRecoilCallback:function(fn,deps){const storeRef=useStoreRef$1(),gotoSnapshot=useGotoRecoilSnapshot();return useCallback$1((...args)=>{function set(recoilState,newValueOrUpdater){setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}function reset(recoilState){setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}const snapshot=cloneSnapshot$1(storeRef.current);let ret=SENTINEL;return batchUpdates$2(()=>{const errMsg="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof fn)throw new Error(errMsg);const cb=fn({set:set,reset:reset,snapshot:snapshot,gotoSnapshot:gotoSnapshot});if("function"!=typeof cb)throw new Error(errMsg);ret=cb(...args)}),ret instanceof Sentinel&&Recoil_invariant(!1),ret},null!=deps?[...deps,storeRef]:void 0)},useRecoilInterface:function(){const storeRef=useStoreRef$1(),[_,forceUpdate]=useState$1([]),recoilValuesUsed=useRef$2(new Set);recoilValuesUsed.current=new Set;const previousSubscriptions=useRef$2(new Set),subscriptions=useRef$2(new Map),unsubscribeFrom=useCallback$1(key=>{const sub=subscriptions.current.get(key);sub&&(sub.release(),subscriptions.current.delete(key))},[subscriptions]),componentName=Recoil_useComponentName();return useEffect$1(()=>{const store=storeRef.current;function updateState(_state,key){subscriptions.current.has(key)&&forceUpdate([])}Recoil_differenceSets(recoilValuesUsed.current,previousSubscriptions.current).forEach(key=>{if(subscriptions.current.has(key))return;const sub=subscribeToRecoilValue$1(store,new AbstractRecoilValue$3(key),state=>{updateState(0,key)},componentName);subscriptions.current.set(key,sub);store.getState().nextTree?store.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{updateState(store.getState(),key)}):updateState(store.getState(),key)}),Recoil_differenceSets(previousSubscriptions.current,recoilValuesUsed.current).forEach(key=>{unsubscribeFrom(key)}),previousSubscriptions.current=recoilValuesUsed.current}),useEffect$1(()=>{const subs=subscriptions.current;return()=>subs.forEach((_,key)=>unsubscribeFrom(key))},[unsubscribeFrom]),useMemo$1(()=>{function useSetRecoilState(recoilState){return newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}}function useRecoilValueLoadable(recoilValue){return recoilValuesUsed.current.has(recoilValue.key)||(recoilValuesUsed.current=setByAddingToSet$2(recoilValuesUsed.current,recoilValue.key)),getRecoilValueAsLoadable$2(storeRef.current,recoilValue)}function useRecoilValue(recoilValue){return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}return{getRecoilValue:useRecoilValue,getRecoilValueLoadable:useRecoilValueLoadable,getRecoilState:function(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},getRecoilStateLoadable:function(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},getSetRecoilState:useSetRecoilState,getResetRecoilState:function(recoilState){return()=>setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}}},[recoilValuesUsed,storeRef])},useRecoilSnapshot:function(){const storeRef=useStoreRef$1(),[snapshot,setSnapshot]=useState$1(()=>cloneSnapshot$1(storeRef.current)),previousSnapshot=usePrevious(snapshot),timeoutID=useRef$2();return useEffect$1(()=>(timeoutID.current&&!isSSR$2&&window.clearTimeout(timeoutID.current),snapshot.retain()),[snapshot]),useTransactionSubscription(useCallback$1(store=>setSnapshot(cloneSnapshot$1(store)),[])),previousSnapshot===snapshot||isSSR$2||(timeoutID.current&&(null==previousSnapshot||previousSnapshot.release_INTERNAL(),window.clearTimeout(timeoutID.current)),snapshot.retain(),timeoutID.current=window.setTimeout(()=>{snapshot.release_INTERNAL(),timeoutID.current=null},12e4)),snapshot},useRecoilState:function(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},useRecoilStateLoadable:function(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},useRecoilTransactionObserver:function(callback){useTransactionSubscription(useCallback$1(store=>{const snapshot=cloneSnapshot$1(store,"current"),previousSnapshot=cloneSnapshot$1(store,"previous");callback({snapshot:snapshot,previousSnapshot:previousSnapshot})},[callback]))},useRecoilValue:useRecoilValue,useRecoilValueLoadable:useRecoilValueLoadable,useRetain:useRetain,useResetRecoilState:function(recoilState){const storeRef=useStoreRef$1();return useCallback$1(()=>{setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)},[storeRef,recoilState])},useSetRecoilState:useSetRecoilState,useSetUnvalidatedAtomValues:function(){const storeRef=useStoreRef$1();return(values,transactionMetadata={})=>{batchUpdates$2(()=>{storeRef.current.addTransactionMetadata(transactionMetadata),values.forEach((value,key)=>setUnvalidatedRecoilValue$2(storeRef.current,new AbstractRecoilValue$3(key),value))})}},useTransactionObservation_DEPRECATED:function(callback){useTransactionSubscription(useCallback$1(store=>{let previousTree=store.getState().previousTree;const currentTree=store.getState().currentTree;previousTree||(previousTree=store.getState().currentTree);const atomValues=externallyVisibleAtomValuesInState(currentTree),previousAtomValues=externallyVisibleAtomValuesInState(previousTree),atomInfo=Recoil_mapMap(nodes$1,node=>{var _node$persistence_UNS,_node$persistence_UNS2,_node$persistence_UNS3,_node$persistence_UNS4;return{persistence_UNSTABLE:{type:null!==(_node$persistence_UNS=null===(_node$persistence_UNS2=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS2?void 0:_node$persistence_UNS2.type)&&void 0!==_node$persistence_UNS?_node$persistence_UNS:"none",backButton:null!==(_node$persistence_UNS3=null===(_node$persistence_UNS4=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS4?void 0:_node$persistence_UNS4.backButton)&&void 0!==_node$persistence_UNS3&&_node$persistence_UNS3}}}),modifiedAtoms=Recoil_filterSet(currentTree.dirtyAtoms,k=>atomValues.has(k)||previousAtomValues.has(k));callback({atomValues:atomValues,previousAtomValues:previousAtomValues,atomInfo:atomInfo,modifiedAtoms:modifiedAtoms,transactionMetadata:{...currentTree.transactionMetadata}})},[callback]))},useTransactionSubscription_DEPRECATED:useTransactionSubscription};const{peekNodeInfo:peekNodeInfo$2}=Recoil_FunctionalCore,{useStoreRef:useStoreRef$2}=Recoil_RecoilRoot_react;var Recoil_useGetRecoilValueInfo=function(){const storeRef=useStoreRef$2();return({key:key})=>peekNodeInfo$2(storeRef.current,storeRef.current.getState().currentTree,key)};const{RecoilRoot:RecoilRoot$1,useStoreRef:useStoreRef$3}=Recoil_RecoilRoot_react,{useMemo:useMemo$2}=react;var Recoil_useRecoilBridgeAcrossReactRoots=function(){const store=useStoreRef$3().current;return useMemo$2(()=>function({children:children}){return react.createElement(RecoilRoot$1,{store_INTERNAL:store},children)},[store])};var Recoil_stableStringify=function(x,opt={allowFunctions:!1}){return function stringify(x,opt,key){if("string"==typeof x&&!x.includes('"')&&!x.includes("\\"))return`"${x}"`;switch(typeof x){case"undefined":return"";case"boolean":return x?"true":"false";case"number":case"symbol":return String(x);case"string":return JSON.stringify(x);case"function":if(!0!==(null==opt?void 0:opt.allowFunctions))throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${x.name})__`}if(null===x)return"null";var _JSON$stringify;if("object"!=typeof x)return null!==(_JSON$stringify=JSON.stringify(x))&&void 0!==_JSON$stringify?_JSON$stringify:"";if(Recoil_isPromise(x))return"__PROMISE__";if(Array.isArray(x))return`[${x.map((v,i)=>stringify(v,opt,i.toString()))}]`;if("function"==typeof x.toJSON)return stringify(x.toJSON(key),opt,key);if(x instanceof Map){const obj={};for(const[k,v]of x)obj["string"==typeof k?k:stringify(k,opt)]=v;return stringify(obj,opt,key)}return x instanceof Set?stringify(Array.from(x).sort((a,b)=>stringify(a,opt).localeCompare(stringify(b,opt))),opt,key):void 0!==Symbol&&null!=x[Symbol.iterator]&&"function"==typeof x[Symbol.iterator]?stringify(Array.from(x),opt,key):`{${Object.keys(x).filter(key=>void 0!==x[key]).sort().map(key=>`${stringify(key,opt)}:${stringify(x[key],opt,key)}`).join(",")}}`}(x,opt)};const findLeaf=(root,getNodeValue,handlers)=>{var _handlers$onNodeVisit;if(null==root)return;if(null==handlers||null===(_handlers$onNodeVisit=handlers.onNodeVisit)||void 0===_handlers$onNodeVisit||_handlers$onNodeVisit.call(handlers,root),"leaf"===root.type)return root;const nodeValue=getNodeValue(root.nodeKey);return findLeaf(root.branches.get(nodeValue),getNodeValue,handlers)},addLeaf=(root,route,parent,value,branchKey,handlers)=>{var _handlers$onNodeVisit2;let node;if(null==root)if(0===route.length)node={type:"leaf",value:value,parent:parent,branchKey:branchKey};else{const[path,...rest]=route,[nodeKey,nodeValue]=path;node={type:"branch",nodeKey:nodeKey,parent:parent,branches:new Map,branchKey:branchKey},node.branches.set(nodeValue,addLeaf(null,rest,node,value,nodeValue,handlers))}else if(node=root,route.length){const[path,...rest]=route,[nodeKey,nodeValue]=path;("branch"!==root.type||root.nodeKey!==nodeKey)&&Recoil_invariant(!1),root.branches.set(nodeValue,addLeaf(root.branches.get(nodeValue),rest,root,value,nodeValue,handlers))}return null==handlers||null===(_handlers$onNodeVisit2=handlers.onNodeVisit)||void 0===_handlers$onNodeVisit2||_handlers$onNodeVisit2.call(handlers,node),node},pruneNodeFromTree=(root,node,parent)=>parent?(parent.branches.delete(node.branchKey),pruneUpstreamBranches(root,parent,parent.parent)):root===node,pruneUpstreamBranches=(root,branchNode,parent)=>parent?(0===branchNode.branches.size&&parent.branches.delete(branchNode.branchKey),pruneUpstreamBranches(root,parent,parent.parent)):root===branchNode,countDownstreamLeaves=node=>"leaf"===node.type?1:Array.from(node.branches.values()).reduce((sum,currNode)=>sum+countDownstreamLeaves(currNode),0);var Recoil_TreeCache_1=class{constructor(options){var _options$onHit,_options$onSet,_options$mapNodeValue;_defineProperty(this,"_numLeafs",void 0),_defineProperty(this,"_root",void 0),_defineProperty(this,"_onHit",void 0),_defineProperty(this,"_onSet",void 0),_defineProperty(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(_options$onHit=null==options?void 0:options.onHit)&&void 0!==_options$onHit?_options$onHit:()=>{},this._onSet=null!==(_options$onSet=null==options?void 0:options.onSet)&&void 0!==_options$onSet?_options$onSet:()=>{},this._mapNodeValue=null!==(_options$mapNodeValue=null==options?void 0:options.mapNodeValue)&&void 0!==_options$mapNodeValue?_options$mapNodeValue:val=>val}size(){return this._numLeafs}root(){return this._root}get(getNodeValue,handlers){var _this$getLeafNode;return null===(_this$getLeafNode=this.getLeafNode(getNodeValue,handlers))||void 0===_this$getLeafNode?void 0:_this$getLeafNode.value}getLeafNode(getNodeValue,handlers){return findLeaf(this.root(),nodeKey=>this._mapNodeValue(getNodeValue(nodeKey)),{onNodeVisit:node=>{null==handlers||handlers.onNodeVisit(node),"leaf"===node.type&&this._onHit(node)}})}set(route,value,handlers){let leafNode;const newRoot=addLeaf(this.root(),route.map(([nodeKey,nodeValue])=>[nodeKey,this._mapNodeValue(nodeValue)]),null,value,null,{onNodeVisit:node=>{null==handlers||handlers.onNodeVisit(node),"leaf"===node.type&&(leafNode=node)}});this.root()||(this._root=newRoot),this._numLeafs++,this._onSet(Recoil_nullthrows(leafNode))}delete(node){if(!this.root())return!1;const root=Recoil_nullthrows(this.root());return!!pruneNodeFromTree(root,node,node.parent)&&(node===root||"branch"===root.type&&!root.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=countDownstreamLeaves(node),!0))}clear(){this._numLeafs=0,this._root=null}},Recoil_TreeCache$1=Object.freeze({__proto__:null,TreeCache:Recoil_TreeCache_1});var Recoil_LRUCache_1=class{constructor(options){var _options$mapKey;_defineProperty(this,"_maxSize",void 0),_defineProperty(this,"_size",void 0),_defineProperty(this,"_head",void 0),_defineProperty(this,"_tail",void 0),_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._maxSize=options.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(_options$mapKey=options.mapKey)&&void 0!==_options$mapKey?_options$mapKey:v=>v}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(key){return this._map.has(this._keyMapper(key))}get(key){const mappedKey=this._keyMapper(key),node=this._map.get(mappedKey);if(node)return this.set(key,node.value),node.value}set(key,val){const mappedKey=this._keyMapper(key);this._map.get(mappedKey)&&this.delete(key);const head=this.head(),node={key:key,right:head,left:null,value:val};head?head.left=node:this._tail=node,this._map.set(mappedKey,node),this._head=node,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const tail=this.tail();tail&&this.delete(tail.key)}delete(key){const mappedKey=this._keyMapper(key);if(!this._size||!this._map.has(mappedKey))return;const node=Recoil_nullthrows(this._map.get(mappedKey)),right=node.right,left=node.left;right&&(right.left=node.left),left&&(left.right=node.right),node===this.head()&&(this._head=right),node===this.tail()&&(this._tail=left),this._map.delete(mappedKey),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Recoil_LRUCache$1=Object.freeze({__proto__:null,LRUCache:Recoil_LRUCache_1});const{LRUCache:LRUCache$1}=Recoil_LRUCache$1,{TreeCache:TreeCache$1}=Recoil_TreeCache$1;var Recoil_treeCacheLRU=function(maxSize,mapNodeValue=(v=>v)){const lruCache=new LRUCache$1({maxSize:maxSize}),cache=new TreeCache$1({mapNodeValue:mapNodeValue,onHit:node=>{lruCache.set(node,!0)},onSet:node=>{const lruNode=lruCache.tail();lruCache.set(node,!0),lruNode&&cache.size()>maxSize&&cache.delete(lruNode.key)}});return cache};const{TreeCache:TreeCache$2}=Recoil_TreeCache$1,defaultPolicy={equality:"reference",eviction:"none",maxSize:1/0};var Recoil_treeCacheFromPolicy=function({equality:equality=defaultPolicy.equality,eviction:eviction=defaultPolicy.eviction,maxSize:maxSize=defaultPolicy.maxSize}=defaultPolicy){return function(eviction,maxSize,mapNodeValue){switch(eviction){case"none":return new TreeCache$2({mapNodeValue:mapNodeValue});case"lru":return Recoil_treeCacheLRU(Recoil_nullthrows(maxSize),mapNodeValue)}throw new Error("Unrecognized eviction policy "+eviction)}(eviction,maxSize,function(equality){switch(equality){case"reference":return val=>val;case"value":return val=>Recoil_stableStringify(val)}throw new Error("Unrecognized equality policy "+equality)}(equality))};var Recoil_PerformanceTimings={startPerfBlock:function(_id){return()=>null}};const{CANCELED:CANCELED$2,Canceled:Canceled$1,loadableWithError:loadableWithError$1,loadableWithPromise:loadableWithPromise$1,loadableWithValue:loadableWithValue$1}=Recoil_Loadable,{getNodeLoadable:getNodeLoadable$2,peekNodeLoadable:peekNodeLoadable$1,setNodeValue:setNodeValue$3}=Recoil_FunctionalCore,{saveDependencyMapToStore:saveDependencyMapToStore$1}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$3,RecoilValueNotReady:RecoilValueNotReady$2,getConfigDeletionHandler:getConfigDeletionHandler$1,registerNode:registerNode$1}=Recoil_Node,{isRecoilValue:isRecoilValue$2}=Recoil_RecoilValue$1,{AbstractRecoilValue:AbstractRecoilValue$4}=Recoil_RecoilValue$1,{setRecoilValueLoadable:setRecoilValueLoadable$2}=Recoil_RecoilValueInterface,{retainedByOptionWithDefault:retainedByOptionWithDefault$1}=Recoil_Retention,{cloneSnapshot:cloneSnapshot$2}=Recoil_Snapshot$1,{startPerfBlock:startPerfBlock$1}=Recoil_PerformanceTimings,dependencyStack=[],waitingStores=new Map,getNewExecutionId=(()=>{let executionId=0;return()=>executionId++})();var Recoil_selector=function(options){const{key:key,get:get,cachePolicy_UNSTABLE:cachePolicy}=options,set=null!=options.set?options.set:void 0,cache=Recoil_treeCacheFromPolicy(null!=cachePolicy?cachePolicy:{equality:"reference",eviction:"none"}),retainedBy=retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE),executionInfoMap=new Map;let liveStoresCount=0;function selectorIsLive(){return!Recoil_gkx_1("recoil_memory_managament_2020")||liveStoresCount>0}function getExecutionInfo(store){return executionInfoMap.has(store)||executionInfoMap.set(store,{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}),Recoil_nullthrows(executionInfoMap.get(store))}function selectorInit(store){return liveStoresCount++,store.getState().knownSelectors.add(key),()=>{liveStoresCount--,store.getState().knownSelectors.delete(key),executionInfoMap.delete(store)}}function selectorShouldDeleteConfigOnRelease(){return void 0!==getConfigDeletionHandler$1(key)&&!selectorIsLive()}function notifyStoreWhenAsyncSettles(store,loadable,executionId){if("loading"===loadable.state){let stores=waitingStores.get(executionId);null==stores&&waitingStores.set(executionId,stores=new Set),stores.add(store)}}function getCachedNodeLoadable(store,state,key){if(state.atomValues.has(key))return Recoil_nullthrows(state.atomValues.get(key));const loadable=getNodeLoadable$2(store,state,key),isKeyPointingToSelector=store.getState().knownSelectors.has(key);return"loading"!==loadable.state&&isKeyPointingToSelector&&state.atomValues.set(key,loadable),loadable}function wrapPendingDependencyPromise(store,promise,state,existingDeps,executionId){return promise.then(resolvedDep=>{if(!selectorIsLive())return clearExecutionInfo(store,executionId),CANCELED$2;if(resolvedDep instanceof Canceled$1)return CANCELED$2;const{__key:resolvedDepKey,__value:depValue}=null!=resolvedDep?resolvedDep:{};let bypassSelectorDepCacheOnReevaluation=!0;null!=resolvedDepKey&&(state.atomValues.set(resolvedDepKey,loadableWithValue$1(depValue)),bypassSelectorDepCacheOnReevaluation=!1);const[loadable,depValues]=evaluateSelectorGetter(store,state,executionId,bypassSelectorDepCacheOnReevaluation);if(isLatestExecution(store,executionId)&&updateExecutionInfoDepValues(depValues,store,executionId),maybeFreezeLoadableContents(loadable),"loading"!==loadable.state&&(setCache(state,depValuesToDepRoute(depValues),loadable),setDepsInStore(store,state,new Set(depValues.keys()),executionId),setLoadableInStoreToNotifyDeps(store,loadable,executionId)),"hasError"===loadable.state)throw loadable.contents;return"hasValue"===loadable.state?{__value:loadable.contents,__key:key}:loadable.contents}).catch(error=>{if(!selectorIsLive())return clearExecutionInfo(store,executionId),CANCELED$2;const loadable=loadableWithError$1(error);throw setCache(state,depValuesToDepRoute(existingDeps),loadableWithError$1(error)),setDepsInStore(store,state,new Set(existingDeps.keys()),executionId),setLoadableInStoreToNotifyDeps(store,loadable,executionId),error})}function setLoadableInStoreToNotifyDeps(store,loadable,executionId){isLatestExecution(store,executionId)&&(setExecutionInfo(loadable,store),function(newLoadable,executionId){const stores=waitingStores.get(executionId);if(void 0!==stores){for(const store of stores)setRecoilValueLoadable$2(store,new AbstractRecoilValue$4(key),newLoadable);waitingStores.delete(executionId)}}(loadable,executionId))}function setDepsInStore(store,state,deps,executionId){var _store$getState,_store$getState$curre,_store$getState2,_store$getState2$next,_store$getState$nextT,_store$getState3,_store$getState3$next;(isLatestExecution(store,executionId)||state.version===(null===(_store$getState=store.getState())||void 0===_store$getState||null===(_store$getState$curre=_store$getState.currentTree)||void 0===_store$getState$curre?void 0:_store$getState$curre.version)||state.version===(null===(_store$getState2=store.getState())||void 0===_store$getState2||null===(_store$getState2$next=_store$getState2.nextTree)||void 0===_store$getState2$next?void 0:_store$getState2$next.version))&&saveDependencyMapToStore$1(new Map([[key,deps]]),store,null!==(_store$getState$nextT=null===(_store$getState3=store.getState())||void 0===_store$getState3||null===(_store$getState3$next=_store$getState3.nextTree)||void 0===_store$getState3$next?void 0:_store$getState3$next.version)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree.version)}function evaluateSelectorGetter(store,state,executionId,bypassSelectorDepCache=!1){const endPerfBlock=startPerfBlock$1(key);let result,loadable,resultIsError=!1;const depValues=new Map,deps=new Set;function getRecoilValue(recoilValue){const{key:depKey}=recoilValue;!function(store,state,deps,newDepKey,executionId){deps.add(newDepKey),setDepsInStore(store,state,deps,executionId)}(store,state,deps,depKey,executionId);const depLoadable=bypassSelectorDepCache?getNodeLoadable$2(store,state,depKey):getCachedNodeLoadable(store,state,depKey);if(maybeFreezeLoadableContents(depLoadable),depValues.set(depKey,depLoadable),"hasValue"===depLoadable.state)return depLoadable.contents;throw depLoadable.contents}setDepsInStore(store,state,deps,executionId);let gateCallback=!1;const getCallback=fn=>(...args)=>{if(!gateCallback)throw new Error("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");const snapshot=cloneSnapshot$2(store),cb=fn({snapshot:snapshot});if("function"!=typeof cb)throw new Error("getCallback() expects a function that returns a function.");return cb(...args)};try{result=get({get:getRecoilValue,getCallback:getCallback}),result=isRecoilValue$2(result)?getRecoilValue(result):result,gateCallback=!0,Recoil_isPromise(result)?result=function(store,promise,state,depValues,executionId){return promise.then(value=>{if(!selectorIsLive())return clearExecutionInfo(store,executionId),CANCELED$2;const loadable=loadableWithValue$1(value);return setCache(state,depValuesToDepRoute(depValues),loadable),setDepsInStore(store,state,new Set(depValues.keys()),executionId),setLoadableInStoreToNotifyDeps(store,loadable,executionId),{__value:value,__key:key}}).catch(errorOrPromise=>{if(!selectorIsLive())return clearExecutionInfo(store,executionId),CANCELED$2;if(isLatestExecution(store,executionId)&&updateExecutionInfoDepValues(depValues,store,executionId),Recoil_isPromise(errorOrPromise))return wrapPendingDependencyPromise(store,errorOrPromise,state,depValues,executionId);const loadable=loadableWithError$1(errorOrPromise);throw setCache(state,depValuesToDepRoute(depValues),loadable),setDepsInStore(store,state,new Set(depValues.keys()),executionId),setLoadableInStoreToNotifyDeps(store,loadable,executionId),errorOrPromise})}(store,result,state,depValues,executionId).finally(endPerfBlock):endPerfBlock()}catch(errorOrDepPromise){result=errorOrDepPromise,Recoil_isPromise(result)?result=wrapPendingDependencyPromise(store,result,state,depValues,executionId).finally(endPerfBlock):(resultIsError=!0,endPerfBlock())}return loadable=resultIsError?loadableWithError$1(result):Recoil_isPromise(result)?loadableWithPromise$1(result):loadableWithValue$1(result),maybeFreezeLoadableContents(loadable),[loadable,depValues]}function depValuesToDepRoute(depValues){return Array.from(depValues.entries()).map(([key,valLoadable])=>[key,valLoadable.contents])}function getValFromRunningNewExecutionAndUpdatedDeps(store,state){const newExecutionId=getNewExecutionId(),[loadable,newDepValues]=evaluateSelectorGetter(store,state,newExecutionId);return setExecutionInfo(loadable,store,newDepValues,newExecutionId,state),function(state,depRoute,loadable){"loading"!==loadable.state&&setCache(state,depRoute,loadable)}(state,depValuesToDepRoute(newDepValues),loadable),notifyStoreWhenAsyncSettles(store,loadable,newExecutionId),loadable}function getSelectorValAndUpdatedDeps(store,state){const cachedVal=function(store,state){const depsAfterCacheDone=new Set,executionInfo=getExecutionInfo(store),cachedVal=cache.get(nodeKey=>{"string"!=typeof nodeKey&&Recoil_invariant(!1);return getCachedNodeLoadable(store,state,nodeKey).contents},{onNodeVisit:node=>{"branch"===node.type&&node.nodeKey!==key&&"string"==typeof node.nodeKey&&depsAfterCacheDone.add(node.nodeKey)}});return cachedVal&&setDepsInStore(store,state,depsAfterCacheDone,executionInfo.latestExecutionId),cachedVal}(store,state);if(null!=cachedVal)return setExecutionInfo(cachedVal,store),cachedVal;const inProgressExecutionInfo=function(store,state){var _Array$from$find;const[,executionInfo]=null!==(_Array$from$find=Array.from(executionInfoMap.entries()).find(([,executionInfo])=>null!=executionInfo.latestLoadable&&null!=executionInfo.latestExecutionId&&!function(store,state){var _executionInfo$depVal,_mapOfCheckedVersions;const executionInfo=getExecutionInfo(store),oldDepValues=null!==(_executionInfo$depVal=executionInfo.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==_executionInfo$depVal?_executionInfo$depVal:new Map,cachedDepValuesCheckedForThisVersion=Array((null!==(_mapOfCheckedVersions=mapOfCheckedVersions.get(state.version))&&void 0!==_mapOfCheckedVersions?_mapOfCheckedVersions:new Map).entries()),isCachedVersionSame=mapOfCheckedVersions.has(state.version)&&cachedDepValuesCheckedForThisVersion.length===oldDepValues.size&&cachedDepValuesCheckedForThisVersion.every(([nodeKey,nodeVal])=>oldDepValues.get(nodeKey)===nodeVal);if(null==oldDepValues||state.version===executionInfo.stateVersion||isCachedVersionSame)return!1;return mapOfCheckedVersions.set(state.version,new Map(oldDepValues)),Array.from(oldDepValues).some(([nodeKey,oldVal])=>{const loadable=getCachedNodeLoadable(store,state,nodeKey);return loadable.contents!==oldVal.contents&&!("loading"===oldVal.state&&"loading"!==loadable.state)})}(store,state)))&&void 0!==_Array$from$find?_Array$from$find:[];return executionInfo}(store,state);if(inProgressExecutionInfo){const executionInfo=inProgressExecutionInfo;return notifyStoreWhenAsyncSettles(store,Recoil_nullthrows(executionInfo.latestLoadable),Recoil_nullthrows(executionInfo.latestExecutionId)),Recoil_nullthrows(executionInfo.latestLoadable)}return getValFromRunningNewExecutionAndUpdatedDeps(store,state)}const mapOfCheckedVersions=new Map;function setExecutionInfo(loadable,store,depValues,newExecutionId,state){const executionInfo=getExecutionInfo(store);"loading"===loadable.state?(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=depValues,executionInfo.latestExecutionId=newExecutionId,executionInfo.latestLoadable=loadable,executionInfo.stateVersion=null==state?void 0:state.version):(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=null,executionInfo.latestExecutionId=null,executionInfo.latestLoadable=null,executionInfo.stateVersion=null)}function updateExecutionInfoDepValues(depValues,store,executionId){const executionInfo=getExecutionInfo(store);isLatestExecution(store,executionId)&&(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=depValues)}function clearExecutionInfo(store,executionId){isLatestExecution(store,executionId)&&executionInfoMap.delete(store)}function isLatestExecution(store,executionId){return executionId===getExecutionInfo(store).latestExecutionId}function maybeFreezeLoadableContents(loadable){"loading"!==loadable.state&&loadable.contents}function setCache(state,cacheRoute,loadable){state.atomValues.set(key,loadable),cache.set(cacheRoute,loadable)}function selectorPeek(store,state){return cache.get(nodeKey=>{"string"!=typeof nodeKey&&Recoil_invariant(!1);const peek=peekNodeLoadable$1(store,state,nodeKey);return null==peek?void 0:peek.contents})}function selectorGet(store,state){return function(fn){if(dependencyStack.includes(key)){const message="Recoil selector has circular dependencies: "+dependencyStack.slice(dependencyStack.indexOf(key)).join("  ");return loadableWithError$1(new Error(message))}dependencyStack.push(key);try{return fn()}finally{dependencyStack.pop()}}(()=>getSelectorValAndUpdatedDeps(store,state))}function invalidateSelector(state){state.atomValues.delete(key)}if(null!=set){return registerNode$1({key:key,peek:selectorPeek,get:selectorGet,set:(store,state,newValue)=>{let syncSelectorSetFinished=!1;const writes=new Map;function getRecoilValue({key:key}){if(syncSelectorSetFinished)throw new Error("Recoil: Async selector sets are not currently supported.");const loadable=getCachedNodeLoadable(store,state,key);if(maybeFreezeLoadableContents(loadable),"hasValue"===loadable.state)return loadable.contents;throw"loading"===loadable.state?new RecoilValueNotReady$2(key):loadable.contents}function setRecoilState(recoilState,valueOrUpdater){if(syncSelectorSetFinished)throw new Error("Recoil: Async selector sets are not currently supported.");const newValue="function"==typeof valueOrUpdater?valueOrUpdater(getRecoilValue(recoilState)):valueOrUpdater;setNodeValue$3(store,state,recoilState.key,newValue).forEach((v,k)=>writes.set(k,v))}const ret=set({set:setRecoilState,get:getRecoilValue,reset:function(recoilState){setRecoilState(recoilState,DEFAULT_VALUE$3)}},newValue);if(void 0!==ret)throw Recoil_isPromise(ret)?new Error("Recoil: Async selector sets are not currently supported."):new Error("Recoil: selector set should be a void function.");return syncSelectorSetFinished=!0,writes},init:selectorInit,invalidate:invalidateSelector,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:retainedBy})}return registerNode$1({key:key,peek:selectorPeek,get:selectorGet,init:selectorInit,invalidate:invalidateSelector,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:retainedBy})};const{loadableWithError:loadableWithError$2,loadableWithPromise:loadableWithPromise$2,loadableWithValue:loadableWithValue$2}=Recoil_Loadable,{DEFAULT_VALUE:DEFAULT_VALUE$4,DefaultValue:DefaultValue$2,getConfigDeletionHandler:getConfigDeletionHandler$2,registerNode:registerNode$2,setConfigDeletionHandler:setConfigDeletionHandler$1}=Recoil_Node,{isRecoilValue:isRecoilValue$3}=Recoil_RecoilValue$1,{markRecoilValueModified:markRecoilValueModified$1,setRecoilValue:setRecoilValue$3,setRecoilValueLoadable:setRecoilValueLoadable$3}=Recoil_RecoilValueInterface,{retainedByOptionWithDefault:retainedByOptionWithDefault$2}=Recoil_Retention;function baseAtom(options){const{key:key,persistence_UNSTABLE:persistence}=options,retainedBy=retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);let liveStoresCount=0,defaultLoadable=Recoil_isPromise(options.default)?loadableWithPromise$2(options.default.then(value=>{defaultLoadable=loadableWithValue$2(value);return{__key:key,__value:value}}).catch(error=>{throw defaultLoadable=loadableWithError$2(error),error})):loadableWithValue$2(options.default),cachedAnswerForUnvalidatedValue=void 0;const cleanupEffectsByStore=new Map;const node=registerNode$2({key:key,peek:function(_store,state){var _ref,_state$atomValues$get3,_cachedAnswerForUnval;return null!==(_ref=null!==(_state$atomValues$get3=state.atomValues.get(key))&&void 0!==_state$atomValues$get3?_state$atomValues$get3:null===(_cachedAnswerForUnval=cachedAnswerForUnvalidatedValue)||void 0===_cachedAnswerForUnval?void 0:_cachedAnswerForUnval[1])&&void 0!==_ref?_ref:defaultLoadable},get:function(_store,state){if(state.atomValues.has(key))return Recoil_nullthrows(state.atomValues.get(key));if(state.nonvalidatedAtoms.has(key)){if(null!=cachedAnswerForUnvalidatedValue)return cachedAnswerForUnvalidatedValue;if(null==persistence)return defaultLoadable;const nonvalidatedValue=state.nonvalidatedAtoms.get(key),validatorResult=persistence.validator(nonvalidatedValue,DEFAULT_VALUE$4),validatedValueLoadable=validatorResult instanceof DefaultValue$2?defaultLoadable:loadableWithValue$2(validatorResult);return cachedAnswerForUnvalidatedValue=validatedValueLoadable,cachedAnswerForUnvalidatedValue}return defaultLoadable},set:function(_store,state,newValue){if(state.atomValues.has(key)){const existing=Recoil_nullthrows(state.atomValues.get(key));if("hasValue"===existing.state&&newValue===existing.contents)return new Map}else if(!state.nonvalidatedAtoms.has(key)&&newValue instanceof DefaultValue$2)return new Map;return cachedAnswerForUnvalidatedValue=void 0,(new Map).set(key,loadableWithValue$2(newValue))},init:function(store,initState,trigger){liveStoresCount++;const alreadyKnown=store.getState().knownAtoms.has(key);if(store.getState().knownAtoms.add(key),"loading"===defaultLoadable.state){const notifyDefaultSubscribers=()=>{var _store$getState$nextT3;(null!==(_store$getState$nextT3=store.getState().nextTree)&&void 0!==_store$getState$nextT3?_store$getState$nextT3:store.getState().currentTree).atomValues.has(key)||markRecoilValueModified$1(store,node)};defaultLoadable.contents.then(notifyDefaultSubscribers).catch(notifyDefaultSubscribers)}let initValue=DEFAULT_VALUE$4,pendingSetSelf=null;if(null!=options.effects_UNSTABLE&&!alreadyKnown){let duringInit=!0;const setSelf=effect=>valueOrUpdater=>{if(duringInit){const currentValue=initValue instanceof DefaultValue$2||Recoil_isPromise(initValue)?"hasValue"===defaultLoadable.state?defaultLoadable.contents:DEFAULT_VALUE$4:initValue;initValue="function"==typeof valueOrUpdater?valueOrUpdater(currentValue):valueOrUpdater,Recoil_isPromise(initValue)&&(initValue=initValue.then(value=>(pendingSetSelf={effect:effect,value:value},value)))}else{if(Recoil_isPromise(valueOrUpdater))throw new Error("Setting atoms to async values is not implemented.");"function"!=typeof valueOrUpdater&&(pendingSetSelf={effect:effect,value:valueOrUpdater}),setRecoilValue$3(store,node,"function"==typeof valueOrUpdater?currentValue=>{const newValue=valueOrUpdater(currentValue);return pendingSetSelf={effect:effect,value:newValue},newValue}:valueOrUpdater)}},resetSelf=effect=>()=>setSelf(effect)(DEFAULT_VALUE$4),onSet=effect=>handler=>{store.subscribeToTransactions(currentStore=>{let{currentTree:currentTree,previousTree:previousTree}=currentStore.getState();previousTree||(previousTree=currentTree);const newLoadable=currentTree.atomValues.get(key);if(null==newLoadable||"hasValue"===newLoadable.state){var _previousTree$atomVal,_pendingSetSelf,_pendingSetSelf2,_pendingSetSelf3;const newValue=null!=newLoadable?newLoadable.contents:DEFAULT_VALUE$4,oldLoadable=null!==(_previousTree$atomVal=previousTree.atomValues.get(key))&&void 0!==_previousTree$atomVal?_previousTree$atomVal:defaultLoadable,oldValue="hasValue"===oldLoadable.state?oldLoadable.contents:DEFAULT_VALUE$4;(null===(_pendingSetSelf=pendingSetSelf)||void 0===_pendingSetSelf?void 0:_pendingSetSelf.effect)!==effect||(null===(_pendingSetSelf2=pendingSetSelf)||void 0===_pendingSetSelf2?void 0:_pendingSetSelf2.value)!==newValue?handler(newValue,oldValue):(null===(_pendingSetSelf3=pendingSetSelf)||void 0===_pendingSetSelf3?void 0:_pendingSetSelf3.effect)===effect&&(pendingSetSelf=null)}},key)};for(const effect of null!==(_options$effects_UNST=options.effects_UNSTABLE)&&void 0!==_options$effects_UNST?_options$effects_UNST:[]){var _options$effects_UNST;const cleanup=effect({node:node,trigger:trigger,setSelf:setSelf(effect),resetSelf:resetSelf(effect),onSet:onSet(effect)});null!=cleanup&&cleanupEffectsByStore.set(store,cleanup)}duringInit=!1}if(!(initValue instanceof DefaultValue$2)){var _store$getState$nextT4;const initLoadable=Recoil_isPromise(initValue)?loadableWithPromise$2(function(store,promise){const wrappedPromise=promise.then(value=>{var _store$getState$nextT,_state$atomValues$get;return(null===(_state$atomValues$get=(null!==(_store$getState$nextT=store.getState().nextTree)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get?void 0:_state$atomValues$get.contents)===wrappedPromise&&setRecoilValue$3(store,node,value),{__key:key,__value:value}}).catch(error=>{var _store$getState$nextT2,_state$atomValues$get2;throw(null===(_state$atomValues$get2=(null!==(_store$getState$nextT2=store.getState().nextTree)&&void 0!==_store$getState$nextT2?_store$getState$nextT2:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get2?void 0:_state$atomValues$get2.contents)===wrappedPromise&&setRecoilValueLoadable$3(store,node,loadableWithError$2(error)),error});return wrappedPromise}(store,initValue)):loadableWithValue$2(initValue);initState.atomValues.set(key,initLoadable),null===(_store$getState$nextT4=store.getState().nextTree)||void 0===_store$getState$nextT4||_store$getState$nextT4.atomValues.set(key,initLoadable)}return()=>{var _cleanupEffectsByStor;liveStoresCount--,null===(_cleanupEffectsByStor=cleanupEffectsByStore.get(store))||void 0===_cleanupEffectsByStor||_cleanupEffectsByStor(),cleanupEffectsByStore.delete(store),store.getState().knownAtoms.delete(key)}},invalidate:function(){cachedAnswerForUnvalidatedValue=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==getConfigDeletionHandler$2(key)&&liveStoresCount<=0},dangerouslyAllowMutability:options.dangerouslyAllowMutability,persistence_UNSTABLE:options.persistence_UNSTABLE?{type:options.persistence_UNSTABLE.type,backButton:options.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:retainedBy});return node}function atom(options){const{default:optionsDefault,...restOptions}=options;return isRecoilValue$3(optionsDefault)?function(options){const base=atom({...options,default:DEFAULT_VALUE$4,persistence_UNSTABLE:void 0===options.persistence_UNSTABLE?void 0:{...options.persistence_UNSTABLE,validator:storedValue=>storedValue instanceof DefaultValue$2?storedValue:Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue,DEFAULT_VALUE$4)},effects_UNSTABLE:options.effects_UNSTABLE}),sel=Recoil_selector({key:options.key+"__withFallback",get:({get:get})=>{const baseValue=get(base);return baseValue instanceof DefaultValue$2?options.default:baseValue},set:({set:set},newValue)=>set(base,newValue),dangerouslyAllowMutability:options.dangerouslyAllowMutability});return setConfigDeletionHandler$1(sel.key,getConfigDeletionHandler$2(options.key)),sel}({...restOptions,default:optionsDefault}):baseAtom({...restOptions,default:optionsDefault})}var Recoil_atom=atom;var Recoil_MapCache_1=class{constructor(options){var _options$mapKey;_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(_options$mapKey=null==options?void 0:options.mapKey)&&void 0!==_options$mapKey?_options$mapKey:v=>v}size(){return this._map.size}has(key){return this._map.has(this._keyMapper(key))}get(key){return this._map.get(this._keyMapper(key))}set(key,val){this._map.set(this._keyMapper(key),val)}delete(key){this._map.delete(this._keyMapper(key))}clear(){this._map.clear()}},Recoil_MapCache$1=Object.freeze({__proto__:null,MapCache:Recoil_MapCache_1});const{LRUCache:LRUCache$2}=Recoil_LRUCache$1,{MapCache:MapCache$1}=Recoil_MapCache$1,defaultPolicy$1={equality:"reference",eviction:"none",maxSize:1/0};var Recoil_cacheFromPolicy=function({equality:equality=defaultPolicy$1.equality,eviction:eviction=defaultPolicy$1.eviction,maxSize:maxSize=defaultPolicy$1.maxSize}=defaultPolicy$1){return function(eviction,maxSize,mapKey){switch(eviction){case"none":return new MapCache$1({mapKey:mapKey});case"lru":return new LRUCache$2({mapKey:mapKey,maxSize:Recoil_nullthrows(maxSize)})}throw new Error("Unrecognized eviction policy "+eviction)}(eviction,maxSize,function(equality){switch(equality){case"reference":return val=>val;case"value":return val=>Recoil_stableStringify(val)}throw new Error("Unrecognized equality policy "+equality)}(equality))};const{setConfigDeletionHandler:setConfigDeletionHandler$2}=Recoil_Node;var Recoil_atomFamily=function(options){var _options$cachePolicyF;const atomCache=Recoil_cacheFromPolicy(null!==(_options$cachePolicyF=options.cachePolicyForParams_UNSTABLE)&&void 0!==_options$cachePolicyF?_options$cachePolicyF:{equality:"value",eviction:"none"});return params=>{var _stableStringify;const cachedAtom=atomCache.get(params);if(null!=cachedAtom)return cachedAtom;const{cachePolicyForParams_UNSTABLE:cachePolicyForParams_UNSTABLE,...atomOptions}=options,newAtom=Recoil_atom({...atomOptions,key:`${options.key}__${null!==(_stableStringify=Recoil_stableStringify(params))&&void 0!==_stableStringify?_stableStringify:"void"}`,default:"function"==typeof options.default?options.default(params):options.default,retainedBy_UNSTABLE:"function"==typeof options.retainedBy_UNSTABLE?options.retainedBy_UNSTABLE(params):options.retainedBy_UNSTABLE,effects_UNSTABLE:"function"==typeof options.effects_UNSTABLE?options.effects_UNSTABLE(params):options.effects_UNSTABLE});return atomCache.set(params,newAtom),setConfigDeletionHandler$2(newAtom.key,()=>{atomCache.delete(params)}),newAtom}};const{setConfigDeletionHandler:setConfigDeletionHandler$3}=Recoil_Node;let nextIndex=0;var Recoil_selectorFamily=function(options){var _options$cachePolicyF;const selectorCache=Recoil_cacheFromPolicy(null!==(_options$cachePolicyF=options.cachePolicyForParams_UNSTABLE)&&void 0!==_options$cachePolicyF?_options$cachePolicyF:{equality:"value",eviction:"none"});return params=>{var _stableStringify;const cachedSelector=selectorCache.get(params);if(null!=cachedSelector)return cachedSelector;const myKey=`${options.key}__selectorFamily/${null!==(_stableStringify=Recoil_stableStringify(params,{allowFunctions:!0}))&&void 0!==_stableStringify?_stableStringify:"void"}/${nextIndex++}`,myGet=callbacks=>options.get(params)(callbacks),myCachePolicy=options.cachePolicy_UNSTABLE,retainedBy="function"==typeof options.retainedBy_UNSTABLE?options.retainedBy_UNSTABLE(params):options.retainedBy_UNSTABLE;let newSelector;if(null!=options.set){const set=options.set;newSelector=Recoil_selector({key:myKey,get:myGet,set:(callbacks,newValue)=>set(params)(callbacks,newValue),cachePolicy_UNSTABLE:myCachePolicy,dangerouslyAllowMutability:options.dangerouslyAllowMutability,retainedBy_UNSTABLE:retainedBy})}else newSelector=Recoil_selector({key:myKey,get:myGet,cachePolicy_UNSTABLE:myCachePolicy,dangerouslyAllowMutability:options.dangerouslyAllowMutability,retainedBy_UNSTABLE:retainedBy});return selectorCache.set(params,newSelector),setConfigDeletionHandler$3(newSelector.key,()=>{selectorCache.delete(params)}),newSelector}};const constantSelector=Recoil_selectorFamily({key:"__constant",get:constant=>()=>constant,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Recoil_constSelector=function(constant){return constantSelector(constant)};const throwingSelector=Recoil_selectorFamily({key:"__error",get:message=>()=>{throw new Error(message)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Recoil_errorSelector=function(message){return throwingSelector(message)};var Recoil_readOnlySelector=function(atom){return atom};const{loadableWithError:loadableWithError$3,loadableWithPromise:loadableWithPromise$3,loadableWithValue:loadableWithValue$3}=Recoil_Loadable;function concurrentRequests(getRecoilValue,deps){const results=Array(deps.length).fill(void 0),exceptions=Array(deps.length).fill(void 0);for(const[i,dep]of deps.entries())try{results[i]=getRecoilValue(dep)}catch(e){exceptions[i]=e}return[results,exceptions]}function isError(exp){return null!=exp&&!Recoil_isPromise(exp)}function unwrapDependencies(dependencies){return Array.isArray(dependencies)?dependencies:Object.getOwnPropertyNames(dependencies).map(key=>dependencies[key])}function getValueFromLoadablePromiseResult(result){return null!=result&&"object"==typeof result&&result.hasOwnProperty("__value")?result.__value:result}function wrapResults(dependencies,results){return Array.isArray(dependencies)?results:Object.getOwnPropertyNames(dependencies).reduce((out,key,idx)=>({...out,[key]:results[idx]}),{})}function wrapLoadables(dependencies,results,exceptions){return wrapResults(dependencies,exceptions.map((exception,idx)=>null==exception?loadableWithValue$3(results[idx]):Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception)))}var Recoil_WaitFor={waitForNone:Recoil_selectorFamily({key:"__waitForNone",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return wrapLoadables(dependencies,results,exceptions)}}),waitForAny:Recoil_selectorFamily({key:"__waitForAny",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return exceptions.some(exp=>!Recoil_isPromise(exp))?wrapLoadables(dependencies,results,exceptions):new Promise(resolve=>{for(const[i,exp]of exceptions.entries())Recoil_isPromise(exp)&&exp.then(result=>{results[i]=getValueFromLoadablePromiseResult(result),exceptions[i]=void 0,resolve(wrapLoadables(dependencies,results,exceptions))}).catch(error=>{exceptions[i]=error,resolve(wrapLoadables(dependencies,results,exceptions))})})}}),waitForAll:Recoil_selectorFamily({key:"__waitForAll",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);if(exceptions.every(exp=>null==exp))return wrapResults(dependencies,results);const error=exceptions.find(isError);if(null!=error)throw error;return Promise.all(exceptions).then(exceptionResults=>{return wrapResults(dependencies,(syncResults=results,asyncResults=exceptionResults,asyncResults.map((result,idx)=>void 0===result?syncResults[idx]:result)).map(getValueFromLoadablePromiseResult));var syncResults,asyncResults})}}),waitForAllSettled:Recoil_selectorFamily({key:"__waitForAllSettled",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return exceptions.every(exp=>!Recoil_isPromise(exp))?wrapLoadables(dependencies,results,exceptions):Promise.all(exceptions.map((exp,i)=>Recoil_isPromise(exp)?exp.then(result=>{results[i]=getValueFromLoadablePromiseResult(result),exceptions[i]=void 0}).catch(error=>{results[i]=void 0,exceptions[i]=error}):null)).then(()=>wrapLoadables(dependencies,results,exceptions))}}),noWait:Recoil_selectorFamily({key:"__noWait",get:dependency=>({get:get})=>{try{return loadableWithValue$3(get(dependency))}catch(exception){return Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception)}}})};const{batchUpdates:batchUpdates$3,setBatcher:setBatcher$1}=Recoil_Batching,{DefaultValue:DefaultValue$3}=Recoil_Node,{RecoilRoot:RecoilRoot$2}=Recoil_RecoilRoot_react,{isRecoilValue:isRecoilValue$4}=Recoil_RecoilValue$1,{retentionZone:retentionZone$1}=Recoil_RetentionZone,{freshSnapshot:freshSnapshot$2}=Recoil_Snapshot$1,{useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilCallback:useRecoilCallback$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useRecoilTransactionObserver:useRecoilTransactionObserver$1,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useResetRecoilState:useResetRecoilState$1,useRetain:useRetain$1,useSetRecoilState:useSetRecoilState$1,useSetUnvalidatedAtomValues:useSetUnvalidatedAtomValues$1,useTransactionObservation_DEPRECATED:useTransactionObservation_DEPRECATED$1}=Recoil_Hooks,{noWait:noWait$1,waitForAll:waitForAll$1,waitForAllSettled:waitForAllSettled$1,waitForAny:waitForAny$1,waitForNone:waitForNone$1}=Recoil_WaitFor;var Recoil_index={DefaultValue:DefaultValue$3,RecoilRoot:RecoilRoot$2,useRecoilBridgeAcrossReactRoots_UNSTABLE:Recoil_useRecoilBridgeAcrossReactRoots,atom:Recoil_atom,selector:Recoil_selector,retentionZone:retentionZone$1,atomFamily:Recoil_atomFamily,selectorFamily:Recoil_selectorFamily,constSelector:Recoil_constSelector,errorSelector:Recoil_errorSelector,readOnlySelector:Recoil_readOnlySelector,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useSetRecoilState:useSetRecoilState$1,useResetRecoilState:useResetRecoilState$1,useGetRecoilValueInfo_UNSTABLE:Recoil_useGetRecoilValueInfo,useRetain:useRetain$1,useRecoilCallback:useRecoilCallback$1,useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilTransactionObserver_UNSTABLE:useRecoilTransactionObserver$1,useTransactionObservation_UNSTABLE:useTransactionObservation_DEPRECATED$1,useSetUnvalidatedAtomValues_UNSTABLE:useSetUnvalidatedAtomValues$1,noWait:noWait$1,waitForNone:waitForNone$1,waitForAny:waitForAny$1,waitForAll:waitForAll$1,waitForAllSettled:waitForAllSettled$1,isRecoilValue:isRecoilValue$4,batchUpdates:batchUpdates$3,setBatcher:setBatcher$1,snapshot_UNSTABLE:freshSnapshot$2},Recoil_index_1=Recoil_index.DefaultValue,Recoil_index_2=Recoil_index.RecoilRoot,Recoil_index_3=Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE,Recoil_index_4=Recoil_index.atom,Recoil_index_5=Recoil_index.selector,Recoil_index_6=Recoil_index.retentionZone,Recoil_index_7=Recoil_index.atomFamily,Recoil_index_8=Recoil_index.selectorFamily,Recoil_index_9=Recoil_index.constSelector,Recoil_index_10=Recoil_index.errorSelector,Recoil_index_11=Recoil_index.readOnlySelector,Recoil_index_12=Recoil_index.useRecoilValue,Recoil_index_13=Recoil_index.useRecoilValueLoadable,Recoil_index_14=Recoil_index.useRecoilState,Recoil_index_15=Recoil_index.useRecoilStateLoadable,Recoil_index_16=Recoil_index.useSetRecoilState,Recoil_index_17=Recoil_index.useResetRecoilState,Recoil_index_18=Recoil_index.useGetRecoilValueInfo_UNSTABLE,Recoil_index_19=Recoil_index.useRetain,Recoil_index_20=Recoil_index.useRecoilCallback,Recoil_index_21=Recoil_index.useGotoRecoilSnapshot,Recoil_index_22=Recoil_index.useRecoilSnapshot,Recoil_index_23=Recoil_index.useRecoilTransactionObserver_UNSTABLE,Recoil_index_24=Recoil_index.useTransactionObservation_UNSTABLE,Recoil_index_25=Recoil_index.useSetUnvalidatedAtomValues_UNSTABLE,Recoil_index_26=Recoil_index.noWait,Recoil_index_27=Recoil_index.waitForNone,Recoil_index_28=Recoil_index.waitForAny,Recoil_index_29=Recoil_index.waitForAll,Recoil_index_30=Recoil_index.waitForAllSettled,Recoil_index_31=Recoil_index.isRecoilValue,Recoil_index_32=Recoil_index.batchUpdates,Recoil_index_33=Recoil_index.setBatcher,Recoil_index_34=Recoil_index.snapshot_UNSTABLE;exports.DefaultValue=Recoil_index_1,exports.RecoilRoot=Recoil_index_2,exports.atom=Recoil_index_4,exports.atomFamily=Recoil_index_7,exports.batchUpdates=Recoil_index_32,exports.constSelector=Recoil_index_9,exports.default=Recoil_index,exports.errorSelector=Recoil_index_10,exports.isRecoilValue=Recoil_index_31,exports.noWait=Recoil_index_26,exports.readOnlySelector=Recoil_index_11,exports.retentionZone=Recoil_index_6,exports.selector=Recoil_index_5,exports.selectorFamily=Recoil_index_8,exports.setBatcher=Recoil_index_33,exports.snapshot_UNSTABLE=Recoil_index_34,exports.useGetRecoilValueInfo_UNSTABLE=Recoil_index_18,exports.useGotoRecoilSnapshot=Recoil_index_21,exports.useRecoilBridgeAcrossReactRoots_UNSTABLE=Recoil_index_3,exports.useRecoilCallback=Recoil_index_20,exports.useRecoilSnapshot=Recoil_index_22,exports.useRecoilState=Recoil_index_14,exports.useRecoilStateLoadable=Recoil_index_15,exports.useRecoilTransactionObserver_UNSTABLE=Recoil_index_23,exports.useRecoilValue=Recoil_index_12,exports.useRecoilValueLoadable=Recoil_index_13,exports.useResetRecoilState=Recoil_index_17,exports.useRetain=Recoil_index_19,exports.useSetRecoilState=Recoil_index_16,exports.useSetUnvalidatedAtomValues_UNSTABLE=Recoil_index_25,exports.useTransactionObservation_UNSTABLE=Recoil_index_24,exports.waitForAll=Recoil_index_29,exports.waitForAllSettled=Recoil_index_30,exports.waitForAny=Recoil_index_28,exports.waitForNone=Recoil_index_27,Object.defineProperty(exports,"__esModule",{value:!0})}));
